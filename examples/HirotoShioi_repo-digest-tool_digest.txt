The following text represents the contents of the repository.
Each section begins with ----, followed by the file path and name.
A file list is provided at the beginning. End of repository content is marked by --END--.

----
.gptinclude

----
Dockerfile
# Build stage
FROM ghcr.io/astral-sh/uv:python3.12-bookworm AS builder

WORKDIR /app
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv sync --frozen --no-install-project --no-dev

# Install Python dependencies
COPY pyproject.toml uv.lock README.md ./
RUN uv sync --frozen

# Copy application code
COPY repo_tool ./repo_tool

# Final stage
FROM python:3.12-slim-bookworm

WORKDIR /app

# Create non-root user for the final stage
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Install git in the final stage
RUN apt-get update && apt-get install -y \
    git \
    && rm -rf /var/lib/apt/lists/*

# Copy the virtual environment from builder
COPY --from=builder /app/.venv /app/.venv

# Copy application code
COPY --from=builder /app/repo_tool /app/repo_tool

# Create directories for bind mounts
RUN mkdir -p /app/repositories /app/digests && \
    chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Set environment variables
ENV PATH="/app/.venv/bin:$PATH"
ENV PYTHONPATH=/app
ENV REPO_PATH=/app/repositories
ENV DIGEST_PATH=/app/digests


----
makefile
.PHONY: run-app docker-build docker-up docker-down docker-logs docker-shell clean

run-app:
	fastapi dev repo_tool/api

docker-build:
	docker-compose build

docker-up:
	docker compose up --watch

docker-down:
	docker-compose down

docker-logs:
	docker-compose logs -f

docker-shell:
	docker-compose exec api bash

clean:
	docker-compose down -v
	find . -type d -name "__pycache__" -exec rm -r {} +
	find . -type f -name "*.pyc" -delete
----
pyproject.toml
# https://packaging.python.org/en/latest/
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "repo-digest-tool"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "aiofiles>=24.1.0",
    "fastapi[standard]>=0.115.6",
    "gitpython>=3.1.43",
    "humanize>=4.11.0",
    "jinja2>=3.1.4",
    "langchain>=0.3.9",
    "langchain-core>=0.3.21",
    "langchain-openai>=0.2.11",
    "python-dotenv>=1.0.1",
    "rich>=13.9.4",
    "tiktoken>=0.8.0",
    "typer>=0.15.1",
]

[dependency-groups]
dev = [
    "black>=24.10.0",
    "fastapi-cli>=0.0.6",
    "mypy>=1.13.0",
    "pytest>=8.3.4",
    "ruff>=0.8.2",
    "types-aiofiles>=24.1.0.20240626",
]

[tool.pytest.ini_options]
pythonpath = ["."]
testpaths = ["tests"]

[tool.hatch.build.targets.wheel]
packages = ["repo_tool"]

[tool.ruff]
line-length = 100
lint.select = ["E", "F", "I"]
lint.ignore = ["E501"]
target-version = "py312"

[tool.mypy]
python_version = "3.12"
strict = true

----
test.py
from dotenv import load_dotenv

from repo_tool import GitHub, generate_digest

load_dotenv(override=True)


def main() -> None:
    repo_url = "https://github.com/HirotoShioi/repo-digest-tool"
    branch = None
    prompt = None
    github = GitHub()
    prompt = "I want to know how to use the repository."
    try:
        print("Cloning repository...")
        github.clone(repo_url, branch)
        github.update(repo_url)

        print("Processing repository...")
        repo_path = GitHub.get_repo_path(repo_url)
        generate_digest(repo_path, prompt)
        repos = github.list()
        print(repos)
    except Exception as e:
        print("Error:", e)


if __name__ == "__main__":
    main()

----
.cursorrules

# AI Behavior Customization for Repo Digest Tool

## Expertise and Focus

- You are an expert in CLI application development, Git repository management, and Python tooling, with a strong focus on frameworks such as Typer and GitPython.

## Key Principles

1. Provide concise, technical responses with clear Python examples.
2. Emphasize readability and maintainability in code and CLI workflows.
3. Use descriptive variable and function names that convey purpose explicitly.
4. Adhere to PEP 8 for Python coding style.
5. Highlight best practices for repository handling and digest generation.

## CLI Application Design

- **CLI Framework:** Use Typer for clean, user-friendly command definitions.
- **Repository Operations:** Implement robust handling for cloning, updating, and deleting repositories using GitPython.
- **Digest Generation:** Prioritize flexibility by supporting custom prompts and allowing dynamic digest formats.
- **Error Handling:** Ensure clear error messages for invalid inputs or failed operations.

## Performance Optimization

1. Minimize redundant operations, e.g., use `git pull` for updates instead of re-cloning.
2. Cache repository metadata for faster lookups.
3. Utilize batch operations for managing multiple repositories efficiently.

## Directory Structure and Configuration

- **Repo Storage:** Maintain repositories in the `repo/` directory with a clear naming convention (`{author}@{repo}`).
- **Digest Output:** Store digests in the `digests/` directory with intuitive naming (`{repo_name}_digest.txt`).

## Testing and Documentation

1. Write modular unit tests using `pytest` for all commands and utility functions.
2. Provide usage examples and clear descriptions in `README.md`.
3. Maintain inline comments and docstrings for better code understanding.

## Extension Roadmap

- Add support for multiple repository hosting services (e.g., GitLab, Bitbucket).
- Enhance digest generation to allow filtering by file extensions or directory paths.
- Introduce batch operations for adding or removing repositories.
- Optimize CLI commands with additional flags for granular control.

## Error Handling Guidelines

- Use `try-except` blocks for file I/O and Git operations.
- Validate inputs (e.g., URL formats, branch names) before executing operations.
- Provide actionable feedback on errors (e.g., "Invalid repo URL. Ensure it follows the format `https://github.com/{author}/{repo}`").

## Example Code Guidelines

- **Repository Addition Example**
  ```python
  from git import Repo

  def add_repository(repo_url: str, branch: str = 'main', force: bool = False):
      repo_id = convert_to_repo_id(repo_url)
      repo_path = f"./repo/{repo_id}"
      if not force and os.path.exists(repo_path):
          print(f"Repository {repo_id} already exists. Use --force to overwrite.")
          return
      Repo.clone_from(repo_url, repo_path, branch=branch)
      print(f"Repository {repo_id} added successfully.")
  ```

- **Digest Generation Example**
  ```python
  def generate_digest(repo_path: str, output_path: str, prompt: str = None):
      files = list_files_in_repo(repo_path)
      digest_content = create_digest(files, prompt)
      with open(output_path, 'w') as f:
          f.write(digest_content)
      print(f"Digest saved to {output_path}")
  ```

## Dependencies

- Typer
- GitPython
- pytest
- Rich (optional, for better CLI output formatting)

## Conventions

1. Begin repository operations by validating URLs and paths.
2. Keep CLI commands intuitive and well-documented.
3. Use modular design for extensibility and maintainability.
4. Log key operations and errors for debugging and audits.


----
README.md
# Repo Digest Tool

![スクリーンショット 2024-12-08 10 07 14](https://github.com/user-attachments/assets/e9e5d500-2ba6-40d5-b564-57dd23301e21)

A CLI tool for managing GitHub repositories and generating digest summaries, implemented with Typer.

---

## Features

- **Repository Digest Generation**: Creates digests of repositories and stores them in the `digests/` directory.
- **Repository Management**: Add, remove, update, or list repositories stored locally in the `repositories/` directory.
- **Custom Filtering**: Uses an LLM (Language Learning Model) for advanced filtering of repository contents based on user prompts.
- **HTML Reports**: Generates user-friendly HTML reports summarizing repository statistics and digest contents.

---

## Installation

### Requirements

- Python 3.12 or above
- `git` installed and accessible in your system path

### Setup

1. Clone the repository:

   ```bash
   git clone https://github.com/<your-username>/repo-digest-tool.git
   cd repo-digest-tool
   ```

2. Install dependencies:

   ```bash
   pip install -r requirements.txt
   ```

3. Optional: Install as a package for easier access:
   ```bash
   pip install -e .
   ```

---

## Usage

### CLI Commands

Here’s a quick overview of the commands:

#### Add a Repository

```bash
repo add <repo_url> [--branch <branch>] [--force]
```

- Adds a repository to local storage.
- Example:
  ```bash
  repo add https://github.com/honojs/hono
  repo add https://github.com/honojs/hono --branch develop --force
  ```

#### Remove a Repository

```bash
repo remove <repo_url>
```

- Removes a repository from local storage.
- Example:
  ```bash
  repo remove https://github.com/honojs/hono
  ```

#### List Repositories

```bash
repo list
```

- Lists all repositories stored locally.
- Example:
  ```bash
  repo list
  ```

#### Generate a Digest

```bash
repo digest <repo_url> [--branch <branch>] [--prompt <prompt>] [--force]
```

- Generates a digest for a repository. Optional: specify a branch or a custom LLM filtering prompt.
- Example:
  ```bash
  repo digest https://github.com/honojs/hono
  repo digest https://github.com/honojs/hono --prompt "Focus on APIs"
  ```

#### Clear Repositories

```bash
repo clear [--all | --author <author>]
```

- Clears repositories from local storage. Either all or selectively by author.
- Example:
  ```bash
  repo clear --all
  repo clear --author honojs
  ```

#### Update a Repository

```bash
repo update <repo_url>
```

- Updates a repository by pulling the latest changes.
- Example:
  ```bash
  repo update https://github.com/honojs/hono
  ```

---

## Development Roadmap

1. **Basic Functionality**:

   - Repository management (`add`, `remove`, `list`).
   - Digest generation.

2. **Digest Extensions**:

   - LLM filtering with custom prompts.
   - HTML report generation.

3. **Testing and Documentation**:

   - Unit tests for all commands.
   - Comprehensive documentation.

4. **Future Enhancements**:
   - Multi-language report support.
   - Integration with other platforms (e.g., GitLab).

---

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

---

## Contribution

Contributions are welcome! Please fork the repository and submit a pull request.

----
.dockerignore
.git
.gitignore
.env
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.pytest_cache/
.mypy_cache/
.pyre/
.hypothesis/
.vscode/
repositories/
digests/ 
----
.python-version
3.12

----
docker-compose.yml
services:
  api:
    build: .
    command: fastapi dev --host 0.0.0.0 --port 8000 repo_tool/api
    develop:
      watch:
        - action: sync
          path: ./repo_tool
          target: /app/repo_tool
        - action: rebuild
          path: pyproject.toml
    ports:
      - "8000:8000"
    volumes:
      - ./repositories:/app/repositories
      - ./digests:/app/digests
      - ./.gptinclude:/app/.gptinclude
      - ./.gptignore:/app/.gptignore
    environment:
      - PYTHONPATH=/app
      - PYTHONUNBUFFERED=1
    env_file:
      - .env
    deploy:
      resources:
        limits:
          memory: 4G
        reservations:
          memory: 2G
    cap_add:
      - SYS_PTRACE
    security_opt:
      - seccomp:unconfined

volumes:
  repositories:
  digests: 
----
frontend/tsconfig.node.json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

----
frontend/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Repo Digest Tool</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

----
frontend/tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
    darkMode: ['class'],
    content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
  	extend: {
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};

----
frontend/tsconfig.app.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}

----
frontend/.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

----
frontend/package.json
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc --noEmit && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "generate-types": "openapi-typescript http://0.0.0.0:8000/openapi.json -o src/lib/api/schema.d.ts"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.1",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.62.7",
    "@tanstack/react-query-devtools": "^5.62.7",
    "chart.js": "^4.4.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.468.0",
    "minimatch": "^9.0.0",
    "openapi-fetch": "^0.13.3",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.3.1",
    "react-router": "7.0.2",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.16.0",
    "@tanstack/eslint-plugin-query": "^5.62.1",
    "@types/minimatch": "^5.1.2",
    "@types/node": "^22.10.2",
    "@types/react": "^18.3.1",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.16.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.13.0",
    "openapi-typescript": "^7.4.4",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.16",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.18.0",
    "vite": "^6.0.3"
  },
  "packageManager": "pnpm@9.15.0"
}

----
frontend/components.json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
----
frontend/tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

----
frontend/eslint.config.js
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";
export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": "off",
    },
  }
);

----
frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from "@vitejs/plugin-react";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
    },
  },
});

----
frontend/postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

----
repo_tool/__init__.py
"""
repo-digest-tool: CLI tool to generate a summary of a repository
"""

__version__ = "0.1.0"

from repo_tool.core.contants import DIGEST_DIR
from repo_tool.core.digest import generate_digest
from repo_tool.core.github import GitHub

__all__ = ["generate_digest", "GitHub", "DIGEST_DIR"]

----
repo_tool/cli.py
from datetime import datetime
from typing import Optional

import humanize
import typer
from git.exc import GitCommandError
from rich import box
from rich.console import Console
from rich.table import Table
from typer import Typer

from repo_tool.core.digest import generate_digest
from repo_tool.core.github import GitHub

app = Typer()

github = GitHub()


@app.command(name="add")
def add(
    repo_url: str = typer.Argument(..., help="GitHub repository URL"),
    branch: Optional[str] = typer.Option(None, help="Branch to add"),
    force: bool = typer.Option(False, help="Force re-download if exists"),
) -> None:
    """
    Add a GitHub repository to the tool.
    """
    try:
        typer.secho(f"Adding repository {repo_url}...")
        github.clone(repo_url, branch, force)
        typer.secho(f"Repository {repo_url} was successfully added!")
    except GitCommandError as e:
        typer.secho(f"Git error: {e}", fg=typer.colors.RED)
        raise typer.Abort() from e
    except Exception as e:
        typer.secho(f"An unexpected error occurred: {e}", fg=typer.colors.RED)
        raise typer.Abort() from e


@app.command(name="list")
def list() -> None:
    """
    List all added repositories in a pretty table format.
    """
    repos = github.list()
    console = Console()

    if not repos:
        console.print("No repositories added yet.")
        return

    # Create a table
    table = Table(box=box.SIMPLE)
    table.add_column("Repository Name", justify="left")
    table.add_column("Author", justify="left")
    table.add_column("URL", justify="left")
    table.add_column("Branch", justify="left")
    table.add_column("Last Updated", justify="left", width=20)
    table.add_column("Size", justify="right")

    # Populate the table with repository data
    for repo in repos:
        formatted_time = humanize.naturaltime(datetime.now() - repo.updated_at)
        size = humanize.naturalsize(repo.size)
        table.add_row(
            repo.name,
            repo.author,
            repo.url,
            repo.branch or "N/A",
            formatted_time,
            size,
        )

    # Print the table
    console.print(table)


@app.command(name="remove")
def remove(repo_name: str = typer.Argument(..., help="Repository name")) -> None:
    """
    Remove a repository.
    """
    try:
        repo_exists = github.repo_exists(repo_name)
        if not repo_exists:
            typer.secho(f"Repository {repo_name} not found.", fg=typer.colors.RED)
            return
        github.remove(repo_name)
        typer.secho(f"Repository {repo_name} removed successfully!")
    except Exception as e:
        typer.secho(f"An unexpected error occurred: {e}", fg=typer.colors.RED)
        raise typer.Abort() from e


@app.command(name="clean")
def clean() -> None:
    """
    Clean up all repositories.
    """
    github.clean()


@app.command(name="update")
def update(
    repo_url: Optional[str] = typer.Argument(None, help="Repository URL")
) -> None:
    """
    Update a repository.
    """
    try:
        updated_repos = github.update(repo_url)
        if len(updated_repos) == 0:
            typer.secho("No repositories updated.", fg=typer.colors.YELLOW)
        else:
            for repo in updated_repos:
                typer.secho(f"Updated repository: {repo.name}")
    except Exception as e:
        typer.secho(f"An unexpected error occurred: {e}", fg=typer.colors.RED)
        raise typer.Abort() from e


@app.command(name="digest")
def digest(
    repo_url: str = typer.Argument(..., help="Repository URL"),
    branch: Optional[str] = typer.Option(None, help="Branch to generate digest for"),
    prompt: Optional[str] = typer.Option(None, help="Prompt to generate digest with"),
) -> None:
    """
    Generate a digest for a repository.
    """
    try:
        repo_path = GitHub.get_repo_path(repo_url)
        if not github.repo_exists(repo_url):
            typer.secho(f"Repository {repo_url} not found. Cloning...")
            github.clone(repo_url, branch)
        elif branch:
            github.checkout(repo_path, branch)
        generate_digest(repo_path, prompt)
        typer.secho(
            f"Digest generated successfully at digests/{repo_path.name}.txt",
        )
    except Exception as e:
        typer.secho(f"An unexpected error occurred: {e}", fg=typer.colors.RED)
        raise typer.Abort() from e


if __name__ == "__main__":
    app()

----
tests/github_test.py
import shutil
from pathlib import Path
from typing import Generator

import pytest
from git import GitCommandError

from repo_tool.core.github import REPO_DIR, GitHub

# Constants for testing
TEST_REPO_URL = "https://github.com/octocat/hello-world"  # Small public repository
TEST_REPO_AUTHOR = "octocat"
TEST_REPO_NAME = "hello-world"
TEST_REPO_PATH = Path(REPO_DIR) / TEST_REPO_AUTHOR / TEST_REPO_NAME


@pytest.fixture(scope="function")
def clean_test_environment() -> Generator[None, None, None]:
    """
    Fixture to clean the repository directory before and after each test.
    """
    if Path(REPO_DIR).exists():
        shutil.rmtree(REPO_DIR)
    yield
    if Path(REPO_DIR).exists():
        shutil.rmtree(REPO_DIR)


def test_clone_repository(clean_test_environment: Generator[None, None, None]) -> None:
    """
    Test if a repository can be cloned successfully.
    """
    github = GitHub()
    github.clone(TEST_REPO_URL)
    assert TEST_REPO_PATH.exists()  # Check if the repository path exists
    assert (TEST_REPO_PATH / ".git").exists()  # Check if the repository is Git-managed


def test_clone_repository_invalid_url(
    clean_test_environment: Generator[None, None, None]
) -> None:
    """
    Test cloning a repository with an invalid URL.
    """
    github = GitHub()
    with pytest.raises(GitCommandError):
        github.clone("https://github.com/octocat/invalid-repo")


def test_update_nonexistent_repository(
    clean_test_environment: Generator[None, None, None]
) -> None:
    """
    Test updating a repository that does not exist locally.
    """
    github = GitHub()
    with pytest.raises(ValueError, match="Repository does not exist"):
        github.update(TEST_REPO_URL)


def test_list_repositories(clean_test_environment: Generator[None, None, None]) -> None:
    """
    Test if cloned repositories are listed correctly.
    """
    github = GitHub()
    github.clone(TEST_REPO_URL)
    repositories = github.list()
    assert len(repositories) == 1  # Verify there is one repository
    repository = repositories[0]
    assert repository.name == TEST_REPO_NAME  # Verify repository name
    assert repository.author == TEST_REPO_AUTHOR  # Verify repository author
    assert repository.url == TEST_REPO_URL  # Verify repository URL


def test_list_repositories_empty_directory(
    clean_test_environment: Generator[None, None, None]
) -> None:
    """
    Test listing repositories when no repositories exist.
    """
    github = GitHub()
    repositories = github.list()
    assert len(repositories) == 0  # Should return an empty list


def test_remove_repository(clean_test_environment: Generator[None, None, None]) -> None:
    """
    Test if a repository can be removed successfully.
    """
    github = GitHub()
    github.clone(TEST_REPO_URL)
    github.remove(TEST_REPO_URL)
    assert not TEST_REPO_PATH.exists()  # Check if the repository is removed
    author_path = Path(REPO_DIR) / TEST_REPO_AUTHOR
    assert not author_path.exists()  # Check if the author directory is removed


def test_remove_nonexistent_repository(
    clean_test_environment: Generator[None, None, None]
) -> None:
    """
    Test removing a repository that does not exist.
    """
    github = GitHub()
    github.remove(
        "https://github.com/octocat/nonexistent-repo"
    )  # Should not raise an exception


def test_clean_all_repositories(
    clean_test_environment: Generator[None, None, None]
) -> None:
    """
    Test if all repositories can be cleaned at once.
    """
    github = GitHub()
    github.clone(TEST_REPO_URL)
    github.clean()
    assert not Path(REPO_DIR).exists()  # Check if the base directory is removed


def test_is_valid_repo_url_valid_urls() -> None:
    """
    Test valid repository URLs.
    """
    assert GitHub.is_valid_repo_url("https://github.com/octocat/hello-world") is True
    assert (
        GitHub.is_valid_repo_url("https://github.com/octocat/hello-world.git") is True
    )


def test_is_valid_repo_url_invalid_urls() -> None:
    """
    Test invalid repository URLs.
    """
    assert (
        GitHub.is_valid_repo_url("http://github.com/octocat/hello-world") is False
    )  # Not HTTPS
    assert (
        GitHub.is_valid_repo_url("https://github.com/octocat") is False
    )  # Missing repository name
    assert (
        GitHub.is_valid_repo_url("https://github.com/") is False
    )  # Missing author and repository
    assert (
        GitHub.is_valid_repo_url("https://bitbucket.org/octocat/hello-world") is False
    )  # Not GitHub
    assert GitHub.is_valid_repo_url("invalid_url") is False  # Invalid format


def test_is_valid_repo_url_edge_cases() -> None:
    """
    Test edge cases for repository URLs.
    """
    assert (
        GitHub.is_valid_repo_url("https://github.com/octocat/hello-world-123") is True
    )
    assert GitHub.is_valid_repo_url("https://github.com/octo-cat_/repo.name") is True
    assert (
        GitHub.is_valid_repo_url("https://github.com/octo-cat-/repo-name.git") is True
    )


def test_get_repo_path_valid_urls() -> None:
    """
    Test repository path generation for valid URLs.
    """
    assert (
        GitHub.get_repo_path("https://github.com/octocat/hello-world")
        == Path(REPO_DIR) / "octocat" / "hello-world"
    )
    assert (
        GitHub.get_repo_path("https://github.com/octocat/hello-world.git")
        == Path(REPO_DIR) / "octocat" / "hello-world"
    )


def test_get_repo_path_invalid_urls() -> None:
    """
    Test repository path generation for invalid URLs.
    """
    with pytest.raises(ValueError, match="Invalid repository URL"):
        GitHub.get_repo_path("http://github.com/octocat/hello-world")  # Not HTTPS
    with pytest.raises(ValueError, match="Invalid repository URL"):
        GitHub.get_repo_path("https://github.com/octocat")  # Missing repository name
    with pytest.raises(ValueError, match="Invalid repository URL"):
        GitHub.get_repo_path("invalid_url")  # Invalid format


def test_get_repo_path_edge_cases() -> None:
    """
    Test repository path generation for edge cases.
    """
    assert (
        GitHub.get_repo_path("https://github.com/octocat-123/repo-name.git")
        == Path(REPO_DIR) / "octocat-123" / "repo-name"
    )


def test_remove_github_token_valid_cases() -> None:
    """
    Test removal of GitHub tokens from valid repository URLs.
    """
    assert (
        GitHub.remove_github_token("https://ghp_abc123@github.com/octocat/hello-world")
        == "https://github.com/octocat/hello-world"
    )
    assert (
        GitHub.remove_github_token("https://github.com/octocat/hello-world")
        == "https://github.com/octocat/hello-world"
    )  # No token


def test_remove_github_token_invalid_cases() -> None:
    """
    Test removal of GitHub tokens for invalid URLs.
    """
    assert (
        GitHub.remove_github_token("http://ghp_abc123@github.com/octocat/hello-world")
        == "http://github.com/octocat/hello-world"
    )  # Not HTTPS
    assert (
        GitHub.remove_github_token("invalid_url") == "invalid_url"
    )  # Invalid format remains unchanged


def test_remove_github_token_edge_cases() -> None:
    """
    Test removing GitHub tokens for malformed token cases.
    """
    assert (
        GitHub.remove_github_token("https://partial_token@github.com/octocat/repo")
        == "https://github.com/octocat/repo"
    )
    assert (
        GitHub.remove_github_token("https://token@github.com@github.com/octocat/repo")
        == "https://github.com/octocat/repo"
    )


def test_get_repo_path_security_cases() -> None:
    """
    Test repository path generation for security edge cases.
    """
    with pytest.raises(ValueError, match="Invalid repository URL"):
        GitHub.get_repo_path("https://github.com/../../malicious/repo")

    with pytest.raises(ValueError, match="Invalid repository URL"):
        GitHub.get_repo_path("https://github.com/octocat/hello-world?.git")


def test_resolve_repo_url() -> None:
    # 有効な完全URL
    assert (
        GitHub.resolve_repo_url("https://github.com/author/repo")
        == "https://github.com/author/repo"
    )
    assert (
        GitHub.resolve_repo_url("https://github.com/author/repo.git")
        == "https://github.com/author/repo.git"
    )

    # 有効な短縮形式
    assert GitHub.resolve_repo_url("author/repo") == "https://github.com/author/repo"
    assert (
        GitHub.resolve_repo_url("author/repo.git")
        == "https://github.com/author/repo.git"
    )

    # 無効な形式
    try:
        GitHub.resolve_repo_url("author//repo")
    except ValueError as e:
        assert (
            str(e)
            == "Invalid short-form repository URL. Must match 'author/repo-name' format."
        )

    try:
        GitHub.resolve_repo_url("author/repo/extra")
    except ValueError as e:
        assert (
            str(e)
            == "Invalid short-form repository URL. Must match 'author/repo-name' format."
        )

    try:
        GitHub.resolve_repo_url("author/re..po")
    except ValueError as e:
        assert (
            str(e)
            == "Invalid short-form repository URL. Must match 'author/repo-name' format."
        )

    try:
        GitHub.resolve_repo_url("invalid-url")
    except ValueError as e:
        assert (
            str(e)
            == "Invalid short-form repository URL. Must match 'author/repo-name' format."
        )

----
tests/test_digest.py
import shutil
from pathlib import Path
from typing import Generator

import pytest

from repo_tool import generate_digest
from repo_tool.core.contants import DIGEST_DIR
from repo_tool.core.github import GitHub

REPO_URL = "https://github.com/HirotoShioi/repo-digest-tool"
PROMPT = None


@pytest.fixture(autouse=True)
def cleanup() -> Generator[None, None, None]:
    # Setup - ensure clean state
    if Path(DIGEST_DIR).exists():
        shutil.rmtree(DIGEST_DIR)
    Path(DIGEST_DIR).mkdir(parents=True, exist_ok=True)

    yield

    # Teardown
    if Path(DIGEST_DIR).exists():
        shutil.rmtree(DIGEST_DIR)


def test_digest_file_generation() -> None:
    digest_path = Path(DIGEST_DIR) / "repo-digest-tool.txt"
    github = GitHub()
    github.clone(REPO_URL, branch=None, force=True)

    repo_path = GitHub.get_repo_path(REPO_URL)
    generate_digest(repo_path, PROMPT)

    assert digest_path.exists(), "Digest file should be generated."

    with digest_path.open("r", encoding="utf-8") as f:
        first_line = f.readline().strip()
        assert (
            first_line
            == "The following text represents the contents of the repository."
        )

    file_size = digest_path.stat().st_size
    MIN_DIGEST_SIZE = 40 * 1024
    MAX_DIGEST_SIZE_MB = 1 * 1024 * 1024
    assert file_size > MIN_DIGEST_SIZE, "Digest file size should be larger than 40KB."
    assert (
        file_size <= MAX_DIGEST_SIZE_MB
    ), f"Digest file size should be less than {MAX_DIGEST_SIZE_MB}MB"

    summary_path = Path(DIGEST_DIR) / "repo-digest-tool_report.html"
    assert summary_path.exists(), "Summary file should be generated."

----
docs/status.md
## 12/8/2024

- Gitpython を使ってリポジトリをクローンするようにした。レポジトリの保存先を`repository_name`から、`author/repository_name`へ変更した
- Token Count から Context length へ変更した
- Update docs
- CLI 実装

## 12/11/2024

- https://openapi-ts.dev/introduction

----
docs/repo_digest_tool_specification.md
# Repo Digest Tool Development Plan

## Overview

This is a CLI application for managing repositories and generating digests, implemented using Typer. The tool provides the following features:

---

## Requirements

### Features

1. **Repository Digest Generation**
   - Digests are saved in the `digests` directory.
   - Example: `digests/honojs_hono_digest.txt`
2. **Repository Management**
   - Repositories are saved in the `repo` directory.
   - Provides commands to add, remove, and list repositories.
3. **CLI Command Structure**
   ```
   repo
   ├── add <repo_url> [--branch <branch>] [--force]
   ├── remove <repo_url>
   ├── list
   ├── digest <repo_url> [--branch <branch>] [--prompt <prompt>] [--force]
   ├── clear [--all | --author <author>]
   └── update <repo_url>
   ```

---

## CLI Command Descriptions

The CLI commands and their functionalities are as follows:

### `repo add <repo_url> [--branch <branch>] [--force]`

- **Description**: Adds a repository to the local storage. Optionally, a specific branch can be checked out. The `--force` option re-downloads the repository if it already exists.
- **Example**:
  ```bash
  repo add https://github.com/honojs/hono
  repo add https://github.com/honojs/hono --branch develop --force
  ```

### `repo remove <repo_url>`

- **Description**: Removes a repository from the local storage.
- **Example**:
  ```bash
  repo remove https://github.com/honojs/hono
  ```

### `repo list`

- **Description**: Lists all locally stored repositories, including details such as URL, branch, and last updated date.
- **Example**:
  ```bash
  repo list
  ```

### `repo digest <repo_url> [--branch <branch>] [--prompt <prompt>] [--force]`

- **Description**: Generates a digest for the specified repository. Optionally allows specifying a branch and a custom prompt for LLM-based filtering. The `--force` option regenerates the digest even if it exists.
- **Example**:
  ```bash
  repo digest https://github.com/honojs/hono
  repo digest https://github.com/honojs/hono --prompt "Focus on APIs"
  ```

### `repo clear [--all | --author <author>]`

- **Description**: Clears repositories from local storage. The `--all` option removes all repositories, while `--author` selectively removes repositories by the specified author.
- **Example**:
  ```bash
  repo clear --all
  repo clear --author honojs
  ```

### `repo update <repo_url>`

- **Description**: Updates the specified repository by pulling the latest changes.
- **Example**:
  ```bash
  repo update https://github.com/honojs/hono
  ```

---

## Directory Structure

```
repo-digest-tool/
├── repo_tool/                  # Main application code
│   ├── __init__.py             # Package initialization
│   ├── cli.py                  # CLI entry point
│   ├── core/                   # Core functionalities
│   │   ├── __init__.py         # Submodule initialization
│   │   ├── contants.py         # Constants definition
│   │   ├── digest.py           # Digest generation logic
│   │   ├── filter.py           # File filtering logic
│   │   ├── github.py           # GitHub operations
│   │   ├── llm.py              # LLM-related functionalities
│   │   ├── logger.py           # Logging features
│   │   └── summary.py          # Summary report generation
│   ├── config.py               # Configuration management
├── tests/                      # Test code
│   ├── github_test.py          # Tests for GitHub operations
│   ├── test_digest.py          # Tests for digest generation
│   └── conftest.py             # Shared pytest settings
├── repositories/               # Repository storage directory (generated at runtime)
│   └── (Generated at runtime)
├── digests/                    # Digest storage directory (generated at runtime)
│   └── (Generated at runtime)
├── templates/                  # Templates for reports
│   └── report.html             # HTML template
├── .gitignore                  # Git ignore settings
├── pyproject.toml              # Python project configuration file
├── README.md                   # Project overview and usage
├── LICENSE                     # License
└── requirements.txt            # Required packages
```

---

## Templates

### Purpose of `templates/report.html`

The `templates/report.html` file is used to generate HTML reports summarizing repository statistics and digest results. It serves as the presentation layer for digest outputs, formatted for readability.

---

## LLM Functionality

The tool leverages a Language Learning Model (LLM) to filter files based on relevance. This is particularly useful for large repositories where only specific types of files are needed.

### How LLM Filtering Works:

1. **Input Prompt**: Users can provide a custom prompt describing the filtering criteria.
2. **File Evaluation**: The LLM processes a list of file paths and their metadata to determine relevance.
3. **Batch Processing**: Files are evaluated in batches for efficiency.

### Use Cases:

- Filtering out CI/CD files, configuration files, and binaries.
- Selecting only files relevant for API documentation, tutorials, or code reviews.

### Example Prompts:

- "Focus on API implementation and tests."
- "Exclude CI/CD files and binary outputs. Include Python and Markdown files."

### Advantages:

- **Precision**: Filters files based on user-defined criteria.
- **Adaptability**: Handles different repository structures and use cases.

### Example Workflow:

```bash
repo digest https://github.com/honojs/hono --prompt "Focus on API implementation"
```

Output:

```
Filtered 100 files to 20 relevant files based on the given prompt.
Digest generated: digests/hono_digest.txt
```

---

----
docs/gui_masterplan.md
## App Overview

- **Name**: Repo Digest Viewer
- **Objective**:  
  Provide an intuitive UI to manage local repositories using a React frontend and a Python API backend. This architecture separates the presentation layer from the logic, improving scalability and modularity.

---

## Target Audience

- Software engineers and project managers.
- Users who want to efficiently manage and understand the structure and content of Git repositories.

---

## Core Features

1. **Repository Management** (Frontend + Backend API):
   - View a list of locally available repositories.
   - Add new repositories by cloning from a Git URL.
   - Delete existing repositories.
   - Update repositories to pull the latest changes.
2. **Repository Details** (Frontend + Backend API):
   - View repository metadata (file count, total size, last updated, etc.).
   - Visualize file distribution by size and type using charts.
   - Filter files by extension, size range, and other criteria.
   - Generate a digest file summarizing selected files.
   - Download the digest file.

---

## Technical Stack

- **Frontend**: React (TypeScript, Axios, React Router, Tailwind CSS)
- **Backend**: Python (FastAPI, GitPython)
- **Charting**: Altair
- **Dependencies**:
  - Frontend:
    - `axios`, `react-router-dom`, `tailwindcss`
  - Backend:
    - `fastapi`, `uvicorn`, `gitpython`

---

## Conceptual Data Model

### Repository

```yaml
id: int
name: string
path: string
last_updated: datetime
files: List[File]
```

### File

```yaml
name: string
path: string
size: int (in bytes)
extension: string
```

---

## API Design

### Endpoints

1. **Repository Management**:
   - `GET /repositories`: Retrieve a list of local repositories.
   - `POST /repositories`: Clone a new repository.
   - `DELETE /repositories/{id}`: Delete an existing repository.
   - `PUT /repositories/{id}`: Update a repository (pull changes).
2. **Digest Operations**:
   - `POST /digest`: Generate a digest file based on filtering criteria.
   - `GET /digest/{id}`: Retrieve the generated digest file.

---

## Directory Structure

```plaintext
repo-digest-tool/
├── frontend/                 # React frontend
│   ├── src/
│   │   ├── components/       # Reusable React components
│   │   ├── pages/            # Page-specific components
│   │   ├── services/         # API service calls
│   │   └── App.tsx           # Root React component
│   ├── public/
│   │   └── index.html        # HTML template
│   └── package.json          # Frontend dependencies
├── backend/                  # Python API server
│   ├── app/
│   │   ├── api/
│   │   │   ├── repository.py # Repository management APIs
│   │   │   ├── digest.py     # Digest operations APIs
│   │   ├── main.py           # FastAPI entry point
│   │   └── utils.py          # Shared utilities
│   ├── requirements.txt      # Backend dependencies
│   └── Dockerfile            # Backend Docker configuration
└── README.md                 # Project documentation
```

---

## Development Phases

### Phase 1: API Server Development

- Implement `GET`, `POST`, `DELETE`, `PUT` endpoints for repository management.
- Add `POST` and `GET` endpoints for digest operations.

### Phase 2: Frontend Prototyping

- Create repository management UI:
  - Display list of repositories.
  - Allow repository addition, deletion, and updates.
- Implement React Router for navigation.

### Phase 3: Data Visualization and Digest Generation

- Build repository details page:
  - Show metadata (file count, total size).
  - Visualize file distribution using charts.
- Add filtering and digest generation capabilities.

### Phase 4: UI Refinements

- Enhance design with Tailwind CSS.
- Improve user feedback with notifications and progress indicators.

---

## Challenges and Solutions

1. **API Performance**:
   - Use caching for frequently accessed data.
   - Optimize large file processing with asynchronous operations.
2. **Error Handling**:
   - Add detailed error messages for API failures.
   - Validate user input on both frontend and backend.
3. **Scalability**:
   - Use Docker for deployment.
   - Ensure the backend is stateless for horizontal scaling.

---

## Future Extensions

- Add support for other repository platforms (e.g., GitLab, Bitbucket).
- Implement LLM-based file content summarization.
- Provide advanced repository analytics.

---

----
templates/report.html
<!-- htmlhint template-rule-off -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Repository Digest Report - {{ repo_name }}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .chart-container {
        position: relative;
        height: 500px;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .token-warning {
        color: #dc2626;
      }

      .token-normal {
        color: inherit;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-6">
      <!-- Header -->
      <h1 class="text-4xl font-bold text-center mb-8">
        Repository Digest Report - {{ repo_name }}
      </h1>

      <!-- File Types Distribution & Digest Statistics -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
        <!-- File Types Distribution -->
        <div class="bg-white shadow-md rounded-lg p-6">
          <h2 class="text-xl font-semibold">
            Context length distribution by file type
          </h2>
          <span class="text-sm text-gray-500 block">
            (Total context length for each file type)
          </span>
          <div class="chart-container">
            <canvas id="fileTypesChart"></canvas>
          </div>
        </div>

        <!-- Digest Statistics -->
        <div class="bg-white shadow-md rounded-lg p-6">
          <h2 class="text-xl font-semibold mb-4">Digest Statistics</h2>
          <table
            class="table-auto w-full border-collapse border border-gray-200"
          >
            <tbody>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Context Length (GPT-4o)
                </td>
                <td class="border border-gray-200 px-4 py-2 relative">
                  <span
                    class="{% if summary.context_length > 128000 %}token-warning{% else %}token-normal{% endif %}"
                  >
                    {{ summary.context_length | format_number }}
                  </span>
                  {% if summary.context_length > 128000 %}
                  <div class="group inline-block relative">
                    <span class="text-red-600 underline cursor-help">?</span>
                    <div
                      class="hidden group-hover:block absolute z-10 bg-gray-800 text-white text-sm rounded-md shadow-md px-4 py-2 w-64 -translate-x-1/2 left-1/2"
                    >
                      The context length exceeds the limit of 128,000 for
                      GPT-4o. Consider reducing the content or splitting it into
                      smaller chunks to fit within the limit.
                    </div>
                  </div>
                  {% endif %}
                </td>
              </tr>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Total Files
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ summary.total_files | string | replace(",", "_") |
                  format_number }}
                </td>
              </tr>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Total Size
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ summary.total_size_kb | format_number }} KB
                </td>
              </tr>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Average File Size
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ summary.average_file_size_kb | format_number }} KB
                </td>
              </tr>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Max File Size
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ summary.max_file_size_kb | format_number }} KB
                </td>
              </tr>
              <tr>
                <td class="border border-gray-200 px-4 py-2 font-semibold">
                  Min File Size
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ summary.min_file_size_kb | format_number }} KB
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Top 20 Files by Token Count -->
      <div class="bg-white shadow-md rounded-lg p-6">
        <h2 class="text-xl font-semibold mb-4">
          Top 20 Files by Context Length
        </h2>
        <div class="chart-container">
          <canvas id="fileSizesChart"></canvas>
        </div>
      </div>

      <!-- All Files Table -->
      <div class="bg-white shadow-md rounded-lg p-6 mt-8">
        <h2 class="text-xl font-semibold mb-4">All Files</h2>

        <!-- Search and Display Controls -->
        <div class="flex flex-wrap gap-4 mb-4">
          <!-- Search Input -->
          <div class="flex-grow">
            <input
              type="text"
              id="fileSearchInput"
              placeholder="Search by file name..."
              class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          <!-- Display Count Selector -->
          <div class="flex items-center gap-2">
            <label for="displayCount" class="text-sm text-gray-600"
              >Show:</label
            >
            <select
              id="displayCount"
              class="px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="20">20</option>
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="200">200</option>
              <option value="-1">All</option>
            </select>
          </div>
        </div>

        <!-- Table -->
        <div class="overflow-x-auto">
          <table
            class="min-w-full table-auto border-collapse border border-gray-200"
          >
            <thead>
              <tr class="bg-gray-100">
                <th class="border border-gray-200 px-4 py-2 text-left">
                  File Name
                </th>
                <th class="border border-gray-200 px-4 py-2 text-left">Path</th>
                <th class="border border-gray-200 px-4 py-2 text-left">
                  Extension
                </th>
                <th class="border border-gray-200 px-4 py-2 text-left">
                  Context Length
                </th>
              </tr>
            </thead>
            <tbody id="fileTableBody">
              {% for file in all_files %}
              <tr class="hover:bg-gray-50">
                <td class="border border-gray-200 px-4 py-2">
                  {{ file.name }}
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ file.path }}
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ file.path.split('.')[-1] if '.' in file.path else 'None' }}
                </td>
                <td class="border border-gray-200 px-4 py-2">
                  {{ file.tokens | format_number }}
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>

        <!-- Pagination Info -->
        <div class="mt-4 text-sm text-gray-600">
          Showing <span id="displayedCount">0</span> of
          <span id="totalCount">0</span> files
        </div>
      </div>
    </div>

    <!-- eslint-disable -->
    <!-- prettier-ignore -->
    <script type="text/javascript">
      // @ts-nocheck
      // File Types Pie Chart
      const typeCtx = document.getElementById('fileTypesChart');
      const fileTypesLabels = JSON.parse('{{ file_types_labels | tojson | safe }}');
      const fileTypesData = JSON.parse('{{ file_types_data | tojson | safe }}');

      new Chart(typeCtx, {
        type: 'pie',
        data: {
          labels: fileTypesLabels,
          datasets: [{
            data: fileTypesData,
            backgroundColor: [
              '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
              '#FF9F40', '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0'
            ]
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'right' },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.label}: ${context.raw.toLocaleString()} tokens`;
                }
              }
            }
          }
        }
      });

      // Top 15 Largest Files Bar Chart
      const sizeCtx = document.getElementById('fileSizesChart');
      const fileSizesLabels = JSON.parse('{{ file_sizes_labels | tojson | safe }}');
      const fileSizesData = JSON.parse('{{ file_sizes_data | tojson | safe }}');

      new Chart(sizeCtx, {
        type: 'bar',
        data: {
          labels: fileSizesLabels,
          datasets: [{
            label: 'Context Length',
            data: fileSizesData,
            backgroundColor: '#36A2EB',
            borderColor: '#2693e6',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.raw.toLocaleString()} tokens`;
                }
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: 'File Names' },
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            },
            y: {
              title: { display: true, text: 'Context Length' },
              ticks: { beginAtZero: true }
            }
          }
        }
      });

      // ファイル検索と表示件数の制御
      const fileSearchInput = document.getElementById('fileSearchInput');
      const displayCountSelect = document.getElementById('displayCount');
      const fileTableBody = document.getElementById('fileTableBody');
      const displayedCountSpan = document.getElementById('displayedCount');
      const totalCountSpan = document.getElementById('totalCount');
      const allRows = Array.from(fileTableBody.getElementsByTagName('tr'));

      // 初期表示
      totalCountSpan.textContent = allRows.length;
      updateDisplayedRows();

      // 検索とフィルタリングの関数
      function updateDisplayedRows() {
        const searchText = fileSearchInput.value.toLowerCase();
        const displayCount = parseInt(displayCountSelect.value);
        let visibleCount = 0;
        
        allRows.forEach((row, index) => {
          const fileName = row.getElementsByTagName('td')[0].textContent.toLowerCase();
          const filePath = row.getElementsByTagName('td')[1].textContent.toLowerCase();
          const matchesSearch = fileName.includes(searchText) || filePath.includes(searchText);
          
          if (matchesSearch && (displayCount === -1 || visibleCount < displayCount)) {
            row.style.display = '';
            visibleCount++;
          } else {
            row.style.display = 'none';
          }
        });

        displayedCountSpan.textContent = visibleCount;
      }

      // イベントリスナーの設定
      fileSearchInput.addEventListener('input', updateDisplayedRows);
      displayCountSelect.addEventListener('change', updateDisplayedRows);
    </script>
  </body>
</html>

----
.vscode/settings.json
{
  "editor.formatOnSave": true,
  "[python]": {
    "editor.defaultFormatter": "ms-python.black-formatter"
  },
  "ruff.lint.args": ["--fix"]
}

----
frontend/src/main.tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import Router from "./router.tsx";
import "./index.css";
import Providers from "@/providers";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <Providers>
      <Router />
    </Providers>
  </StrictMode>
);

----
frontend/src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.75rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

----
frontend/src/router.tsx
import { BrowserRouter, Routes, Route } from "react-router";
import RepositoriesPage from "./pages/Repositories";
import RepositoryDetailsPage from "./pages/RepositoryDetails";
import { Layout } from "./components/Layout";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<RepositoriesPage />} />
          <Route path="/:author/:name" element={<RepositoryDetailsPage />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

export default App;

----
frontend/src/vite-env.d.ts
/// <reference types="vite/client" />

declare module "*.svg" {
  const content: string;
  export default content;
}

----
frontend/src/types/index.ts
type Repository = {
  id: string;
  name: string;
  author: string;
  path: string;
  updatedAt: Date;
  branch: string | null;
  url: string;
  size: number;
}


type FileStats = {
  extension: string;
  count: number;
  totalSize: number;
}

type FileFilter = {
  extensions: string[];
  minSize?: number;
  maxSize?: number;
  searchQuery: string;
}

type FileTypeAggregation = {
  extension: string;
  count: number;
  tokens: number;
}

type FileData = {
  name: string;
  path: string;
  extension: string;
  tokens: number;
}

type Summary = {
  repository: string;
  totalFiles: number;
  totalSizeKb: number;
  averageFileSizeKb: number;
  maxFileSizeKb: number;
  minFileSizeKb: number;
  fileTypes: FileTypeAggregation[];
  contextLength: number;
  fileData: FileData[];
}

type Settings = {
  includePatterns: string[];
  excludePatterns: string[];
}

export type { Repository, FileStats, FileFilter, Summary, FileTypeAggregation, FileData, Settings };

----
frontend/src/providers/index.tsx
import { TooltipProvider } from "@radix-ui/react-tooltip";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
    },
  },
});

function Provider({ children }: { children: React.ReactNode }) {
  return (
    <TooltipProvider delayDuration={0}>
      <QueryClientProvider client={queryClient}>
        {children}
        <Toaster />
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    </TooltipProvider>
  );
}

export default Provider;

----
frontend/src/utils/formatters.ts
export function formatSize(bytes: number): string {
  const units = ['B', 'KB', 'MB', 'GB'];
  let size = bytes;
  let unitIndex = 0;
  
  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }
  
  return `${size.toFixed(1)} ${units[unitIndex]}`;
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat('en-US', {
    dateStyle: 'medium',
    timeStyle: 'short'
  }).format(date);
}

export function formatNumber(number: number) {
  if (typeof number === 'number') {
      return number.toLocaleString();
  }
  return String(number)
};
----
frontend/src/components/LoadingButton.tsx
"use client";

import * as React from "react";
import { Loader2 } from "lucide-react";
import { Button, ButtonProps } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export interface LoadingButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  isLoading?: boolean;
  loadingText?: string;
  variant?: ButtonProps["variant"];
}

const LoadingButton = React.forwardRef<HTMLButtonElement, LoadingButtonProps>(
  (
    {
      className,
      children,
      isLoading,
      loadingText,
      disabled,
      variant,
      ...props
    },
    ref
  ) => {
    return (
      <Button
        variant={variant}
        className={cn("flex items-center justify-center", className)}
        disabled={disabled || isLoading}
        ref={ref}
        {...props}
      >
        {isLoading && <Loader2 className="h-4 w-4 animate-spin" />}
        {isLoading ? loadingText : children}
      </Button>
    );
  }
);
LoadingButton.displayName = "LoadingButton";

export { LoadingButton };

----
frontend/src/components/LoadingSpinner.tsx
"use client";

import { Loader2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";

interface LoadingSpinnerProps {
  size?: number;
  className?: string;
  minHeight?: number;
  label?: string;
}

export function LoadingSpinner({
  size = 24,
  className = "",
  minHeight = 100,
  label,
}: LoadingSpinnerProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [height, setHeight] = useState<number | string>("auto");

  useEffect(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const parentHeight = containerRef.current.parentElement?.clientHeight;
        setHeight(
          parentHeight && parentHeight > minHeight ? parentHeight : minHeight
        );
      }
    };

    updateHeight();
    window.addEventListener("resize", updateHeight);

    return () => window.removeEventListener("resize", updateHeight);
  }, [minHeight]);

  return (
    <div ref={containerRef} className="w-full" style={{ height }}>
      <div className="flex items-center justify-center w-full h-full flex-col">
        <Loader2
          className={`animate-spin text-primary ${className}`}
          size={size}
        />
        {label && <div className="text-center py-4 text-gray-600">{label}</div>}
      </div>
    </div>
  );
}

----
frontend/src/components/Layout.tsx
import { Outlet, Link } from "react-router";
import { cn } from "@/lib/utils";
import { FileText, Moon, Sun } from "lucide-react";
import { Button } from "./ui/button";
import { useTheme } from "@/hooks/useTheme";
import githubIcon from "@/assets/github.svg";

export function Layout() {
  const { theme, setTheme } = useTheme();

  return (
    <div className="min-h-screen bg-muted">
      <div className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 sticky top-0 z-50">
        <div className="mx-auto">
          <div className="flex h-14 items-center justify-between px-4">
            {/* Left section */}
            <div className="flex items-center gap-4">
              <Link
                className={cn(
                  "flex items-center gap-2 font-semibold hover:opacity-80"
                )}
                to="/"
              >
                <FileText className="w-5 h-5" />
                <span>Repo Digest Tool</span>
              </Link>
            </div>
            <div className="flex items-center gap-4">
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setTheme(theme === "light" ? "dark" : "light")}
              >
                <Sun className="h-5 w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
                <Moon className="absolute h-5 w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
                <span className="sr-only">Toggle theme</span>
              </Button>
              <a
                href="https://github.com/HirotoShioi/repo-digest-tool"
                target="_blank"
                rel="noopener noreferrer"
              >
                <Button variant="ghost" size="icon">
                  <img src={githubIcon} alt="GitHub" className="h-5 w-5" />
                  <span className="sr-only">GitHub repository</span>
                </Button>
              </a>
            </div>
          </div>
        </div>
      </div>

      <div className="max-w-5xl mx-auto px-4 py-4">
        <Outlet />
      </div>
    </div>
  );
}

----
frontend/src/hooks/useFileStats.ts
import { useState } from 'react';
import type { FileStats, FileFilter } from '../types';

export function useFileStats(author: string, name: string) {
  const [fileStats] = useState<FileStats[]>([
    { extension: '.js', count: 25, totalSize: 156000 },
    { extension: '.ts', count: 15, totalSize: 89000 },
    { extension: '.json', count: 5, totalSize: 12000 },
    { extension: '.md', count: 3, totalSize: 8000 }
  ]);

  const generateDigest = (filter: FileFilter) => {
    console.log('Generating digest for repository:', author, name, 'with filter:', filter);
  };

  return {
    fileStats,
    generateDigest
  };
}
----
frontend/src/hooks/use-toast.ts
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

----
frontend/src/hooks/useTheme.ts
import { useEffect, useState } from "react";

type Theme = "dark" | "light";

export function useTheme() {
  const [theme, setTheme] = useState<Theme>(() => {
    const stored = localStorage.getItem("theme");
    if (stored === "dark" || stored === "light") return stored;
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  });

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(theme);
    localStorage.setItem("theme", theme);
  }, [theme]);

  return { theme, setTheme };
} 
----
frontend/src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function extractAuthorAndNameFromUrl(url: string): {
  author?: string;
  name?: string;
} | null {
  try {
    const urlObj = new URL(url);
    const author = urlObj.pathname.split("/")[1];
    const name = urlObj.pathname.split("/")[2];
    return { author, name };
  } catch (error) {
    console.error(error);
    return null;
  }
}

----
frontend/src/components/ui/card.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

----
frontend/src/components/ui/toaster.tsx
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

----
frontend/src/components/ui/scroll-area.tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

----
frontend/src/components/ui/label.tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

----
frontend/src/components/ui/navigation-menu.tsx
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

----
frontend/src/components/ui/tooltip.tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

----
frontend/src/components/ui/dialog.tsx
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

----
frontend/src/components/ui/badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

----
frontend/src/components/ui/table.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

----
frontend/src/components/ui/button.tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

----
frontend/src/components/ui/toast.tsx
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        success: "border bg-green-500 text-white",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

----
frontend/src/components/ui/checkbox.tsx
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

----
frontend/src/components/ui/select.tsx
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

----
frontend/src/components/ui/input.tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };

----
frontend/src/lib/api/client.ts
import type { paths } from "./schema";
import createClient from "openapi-fetch";

const client = createClient<paths>({
  baseUrl: "http://0.0.0.0:8000",
});

export default client;
----
frontend/src/pages/Repositories/index.tsx
import { useState } from "react";
import { Plus } from "lucide-react";
import { AddRepositoryDialog } from "@/pages/Repositories/components/AddRepositoryDialog";
import { RepositoryList } from "@/pages/Repositories/components/RepositoryList";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useGetRepositories } from "@/services/repositories/queries";
import { LoadingSpinner } from "@/components/LoadingSpinner";

function RepositoriesPage() {
  const { data: repositories, isLoading } = useGetRepositories();
  const [searchQuery, setSearchQuery] = useState("");
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);

  const filteredRepositories = (repositories ?? [])
    .filter(
      (repo) =>
        repo.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        repo.url.toLowerCase().includes(searchQuery.toLowerCase())
    )
    .sort((a, b) => a.name.localeCompare(b.name));

  return (
    <div className="space-y-8">
      <div className="flex items-center gap-4">
        <div className="flex-1 justify-center items-center">
          <Input
            type="text"
            className="w-full border-primary"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search repositories..."
          />
        </div>
        <Button
          onClick={() => setIsAddDialogOpen(true)}
          className="bg-primary hover:bg-primary/90"
        >
          <Plus className="w-5 h-5" />
          Add Repository
        </Button>
      </div>

      {isLoading ? (
        <LoadingSpinner size={48} minHeight={500} />
      ) : (
        <RepositoryList repositories={filteredRepositories} />
      )}

      <AddRepositoryDialog
        isOpen={isAddDialogOpen}
        onClose={() => setIsAddDialogOpen(false)}
      />
    </div>
  );
}

export default RepositoriesPage;

----
frontend/src/pages/RepositoryDetails/index.tsx
import { useParams, useNavigate } from "react-router";
import { useGetRepositoryById } from "@/services/repositories/queries";
import { useGetSummary } from "@/services/summary/queries";
import Report from "./components/Report";
import { Button } from "@/components/ui/button";
import { Download, FileText, Settings } from "lucide-react";
import { useState } from "react";
import { FilterSettingDialog } from "./components/FilterSettingDialog";
import { LoadingSpinner } from "../../components/LoadingSpinner";
import { useGenerateDigest } from "@/services/digest/mutations";
import { LoadingButton } from "@/components/LoadingButton";

function RepositoryDetailsPage() {
  const { author, name } = useParams<{ author: string; name: string }>();
  const [open, setOpen] = useState(false);
  const navigate = useNavigate();
  const { data: repository, isLoading } = useGetRepositoryById({
    author: author,
    name: name,
  });
  const {
    data: summary,
    refetch,
    isLoading: isSummaryLoading,
    isFetching,
  } = useGetSummary({
    author: author,
    name: name,
  });

  const { mutate: generateDigest, isPending: isDigestLoading } =
    useGenerateDigest();

  if (!author || !name) {
    return <div>Repository not found</div>;
  }

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!repository) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">Repository not found</p>
        <button
          onClick={() => navigate("/")}
          className="mt-4 text-blue-600 hover:text-blue-800"
        >
          Return to repository list
        </button>
      </div>
    );
  }

  return (
    <>
      <div className="flex items-center justify-between mb-4">
        <div className="flex gap-2 flex-col">
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <FileText className="w-6 h-6" />
            {repository.name}
          </h1>
          <a
            href={repository.url}
            target="_blank"
            rel="noopener noreferrer"
            className="text-sm text-muted-foreground"
          >
            {repository.url}
          </a>
        </div>
        <div className="flex items-center gap-2">
          <LoadingButton
            isLoading={isDigestLoading}
            variant="outline"
            loadingText="Generating..."
            onClick={() => generateDigest({ author, repositoryName: name })}
          >
            <Download className="w-4 h-4" />
            Get Digest
          </LoadingButton>
          <Button
            size="lg"
            onClick={() => setOpen(true)}
            className="bg-primary hover:bg-primary/90"
          >
            <Settings className="w-4 h-4" />
            Filter
          </Button>
          <FilterSettingDialog
            open={open}
            onOpenChange={setOpen}
            onSave={() => {
              refetch({});
            }}
          />
        </div>
      </div>
      {isFetching && !isSummaryLoading && (
        <div className="fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center">
          <LoadingSpinner size={48} label="Updating digest summary..." />
        </div>
      )}
      {isSummaryLoading ? (
        <LoadingSpinner
          minHeight={500}
          size={48}
          label="Loading digest summary..."
        />
      ) : summary ? (
        <Report summary={summary} author={author} name={name} />
      ) : (
        <div className="text-center py-8 text-gray-600">
          No analysis data available
        </div>
      )}
    </>
  );
}

export default RepositoryDetailsPage;

----
frontend/src/pages/Repositories/components/RepositoryCard.tsx
import { Trash2, RefreshCw, FolderGit2, Loader2 } from "lucide-react";
import type { Repository } from "@/types";
import { formatDate } from "@/utils/formatters";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  useDeleteRepository,
  useUpdateRepository,
} from "@/services/repositories/mutations";
import { usePrefetchRepositoryById } from "@/services/repositories/queries";
import { useNavigate } from "react-router";

interface RepositoryCardProps {
  repository: Repository;
}

export function RepositoryCard({ repository }: RepositoryCardProps) {
  const navigate = useNavigate();
  const { mutate: deleteRepository } = useDeleteRepository();
  const { mutate: updateRepository, isPending: isUpdating } =
    useUpdateRepository();
  function handleDelete() {
    deleteRepository({ repositoryIdOrUrl: repository.url });
  }
  function handleUpdate() {
    updateRepository({ repositoryIdOrUrl: repository.url });
  }

  const prefetch = usePrefetchRepositoryById({
    author: repository.author,
    name: repository.name,
  });
  return (
    <Card
      onMouseEnter={() => prefetch()}
      onClick={() => navigate(`/${repository.author}/${repository.name}`)}
      className={`hover:shadow-lg transition-all cursor-pointer h-full`}
    >
      <CardHeader className="p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4 max-w-[70%]">
            <FolderGit2 className="w-6 h-6 text-primary" />
            <div className="flex flex-col w-full">
              <h3 className="text-lg font-semibold">{repository.name}</h3>
              <p className="text-sm text-muted-foreground truncate">
                {repository.url}
              </p>
            </div>
          </div>
          <div className="flex items-center space-x-2">
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleUpdate();
                  }}
                  size="icon"
                  variant="ghost"
                  disabled={isUpdating}
                >
                  {isUpdating ? (
                    <Loader2 className="w-4 h-4 animate-spin" />
                  ) : (
                    <RefreshCw className="w-4 h-4" />
                  )}
                </Button>
              </TooltipTrigger>
              <TooltipContent>Update repository</TooltipContent>
            </Tooltip>

            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete();
                  }}
                  size="icon"
                  variant="ghost"
                  className="hover:text-destructive hover:bg-destructive/10"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>Delete repository</TooltipContent>
            </Tooltip>
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-4 pt-0">
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div className="bg-muted p-3 rounded-md">
            <p className="text-muted-foreground">Author</p>
            <p className="font-semibold">{repository.author}</p>
          </div>
          <div className="bg-muted p-3 rounded-md">
            <p className="text-muted-foreground">Last Updated</p>
            <p className="font-semibold">{formatDate(repository.updatedAt)}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

----
frontend/src/pages/Repositories/components/AddRepository.tsx
import React, { useState } from "react";
import { GitBranch } from "lucide-react";

interface AddRepositoryProps {
  onAdd: (url: string) => void;
}

export function AddRepository({ onAdd }: AddRepositoryProps) {
  const [url, setUrl] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (url.trim()) {
      onAdd(url.trim());
      setUrl("");
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="bg-white rounded-lg shadow-md p-6 mb-6"
    >
      <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
        <GitBranch className="w-5 h-5 text-blue-600" />
        Add New Repository
      </h2>
      <div className="flex gap-4">
        <input
          type="text"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="Enter Git repository URL"
          className="flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
        />
        <button
          type="submit"
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
        >
          Clone Repository
        </button>
      </div>
    </form>
  );
}

----
frontend/src/pages/Repositories/components/RepositoryList.tsx
import type { Repository } from "../../../types";
import { RepositoryCard } from "./RepositoryCard";

interface RepositoryListProps {
  repositories: Repository[];
}

export function RepositoryList({ repositories }: RepositoryListProps) {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 gap-4">
      {repositories.map((repo) => (
        <RepositoryCard repository={repo} key={repo.id} />
      ))}
      {repositories.length === 0 && (
        <div className="text-center py-8 text-gray-500">
          No repositories added yet. Add one using the form above.
        </div>
      )}
    </div>
  );
}

----
frontend/src/pages/Repositories/components/AddRepositoryDialog.tsx
import React, { useState } from "react";
import { GitBranch } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useCloneRepository } from "@/services/repositories/mutations";
import { useToast } from "@/hooks/use-toast";
import { LoadingButton } from "@/components/LoadingButton";
interface AddRepositoryDialogProps {
  isOpen: boolean;
  onClose: () => void;
}

export function AddRepositoryDialog({
  isOpen,
  onClose,
}: AddRepositoryDialogProps) {
  const [url, setUrl] = useState("");
  const { toast } = useToast();
  const { mutate: cloneRepository, isPending } = useCloneRepository();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (url.trim()) {
      cloneRepository(
        { repositoryIdOrUrl: url.trim() },
        {
          onSuccess: () => {
            setUrl("");
            onClose();
            toast({
              title: "Repository cloned successfully",
              description: "The repository has been added to your list.",
              variant: "success",
            });
          },
        }
      );
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            <div className="flex items-center gap-2">
              <GitBranch className="w-5 h-5" />
              Add New Repository
            </div>
            <DialogDescription>
              Add a new repository to your list.
            </DialogDescription>
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label
              htmlFor="repo-url"
              className="block text-sm font-medium mb-2"
            >
              Repository URL
            </label>
            <Input
              id="repo-url"
              type="text"
              value={url}
              onChange={(e) => setUrl(e.target.value)}
              placeholder="Enter Git repository URL"
            />
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <LoadingButton
              type="submit"
              isLoading={isPending}
              loadingText="Cloning..."
            >
              Clone Repository
            </LoadingButton>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

----
frontend/src/pages/RepositoryDetails/components/AllFilesTable.tsx
import { useState, useMemo } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { FileData } from "@/types";
import { formatNumber } from "@/utils/formatters";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { useExcludeFiles } from "@/services/settings/mutations";
import { useToast } from "@/hooks/use-toast";

interface AllFilesTableParams {
  fileData: FileData[];
  author: string;
  name: string;
}

function AllFilesTable({ fileData, author, name }: AllFilesTableParams) {
  const { mutate: excludeFiles } = useExcludeFiles();
  const [searchText, setSearchText] = useState("");
  const [displayCount, setDisplayCount] = useState(20);
  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set());

  const filteredFiles = useMemo(() => {
    const normalizedSearchText = searchText.toLowerCase();
    return fileData.filter((file) => {
      const fileName = file.name.toLowerCase();
      const filePath = file.path.toLowerCase();
      return (
        fileName.includes(normalizedSearchText) ||
        filePath.includes(normalizedSearchText)
      );
    });
  }, [fileData, searchText]);

  const displayedFiles = useMemo(() => {
    if (displayCount === -1) {
      return filteredFiles;
    }
    return filteredFiles.slice(0, displayCount);
  }, [filteredFiles, displayCount]);

  const displayedCount = displayedFiles.length;
  const totalCount = filteredFiles.length;

  const handleCheckboxChange = (filePath: string) => {
    setSelectedFiles((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(filePath)) {
        newSet.delete(filePath);
      } else {
        newSet.add(filePath);
      }
      return newSet;
    });
  };

  const { toast } = useToast();
  const handleFilterClick = () => {
    excludeFiles(
      {
        author,
        name,
        paths: Array.from(selectedFiles),
      },
      {
        onError: (error) => {
          toast({
            title: "Failed to update filter",
            description: error.message,
            variant: "destructive",
          });
        },
        onSuccess: () => {
          toast({
            title: "Filter updated",
          });
        },
      }
    );
    setSelectedFiles(new Set());
  };

  return (
    <Card className="p-2 mt-8">
      <CardHeader className="p-4">
        <CardTitle>All Files</CardTitle>
      </CardHeader>
      <CardContent className="p-4">
        {/* Search and Display Controls */}
        <div className="flex flex-wrap gap-4 mb-4">
          {/* Search Input */}
          <div className="flex-grow">
            <Input
              type="text"
              placeholder="Search by file name..."
              value={searchText}
              onChange={(e) => setSearchText(e.target.value)}
            />
          </div>

          {/* Add Filter Button */}
          <Button
            onClick={handleFilterClick}
            disabled={selectedFiles.size === 0}
            variant="secondary"
          >
            Filter ({selectedFiles.size})
          </Button>

          {/* Display Count Selector */}
          <div className="flex items-center gap-2">
            <Label htmlFor="displayCount" className="text-sm text-gray-600">
              Show:
            </Label>
            <Select
              onValueChange={(value) => setDisplayCount(parseInt(value, 10))}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Select a number of files" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="20">20</SelectItem>
                <SelectItem value="50">50</SelectItem>
                <SelectItem value="100">100</SelectItem>
                <SelectItem value="200">200</SelectItem>
                <SelectItem value="-1">All</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="overflow-x-auto">
          <Table className="min-w-full">
            <TableHeader>
              <TableRow>
                <TableHead className="w-[50px]"></TableHead>
                <TableHead className="text-left">File Name</TableHead>
                <TableHead className="text-left">Path</TableHead>
                <TableHead className="text-left">File Type</TableHead>
                <TableHead className="text-left">Context Length</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {displayedFiles.map((file, index) => (
                <TableRow key={index} className="hover:bg-muted">
                  <TableCell>
                    <Checkbox
                      checked={selectedFiles.has(file.path)}
                      onCheckedChange={() => handleCheckboxChange(file.path)}
                    />
                  </TableCell>
                  <TableCell>{file.name}</TableCell>
                  <TableCell>{file.path}</TableCell>
                  <TableCell>{file.extension || "None"}</TableCell>
                  <TableCell>{formatNumber(file.tokens)}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>

        {/* Pagination Info */}
        <div className="mt-4 text-sm text-gray-600">
          Showing <span id="displayedCount">{displayedCount}</span> of{" "}
          <span id="totalCount">{totalCount}</span> files
        </div>
      </CardContent>
    </Card>
  );
}

export default AllFilesTable;

----
frontend/src/pages/RepositoryDetails/components/FilterSettingDialog.tsx
"use client";
import { useState, useEffect, memo, useCallback } from "react";
import { Plus, X } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useGetSettings } from "@/services/settings/queries";
import { useUpdateSettings } from "@/services/settings/mutations";
import { useToast } from "@/hooks/use-toast";
import { Minimatch } from "minimatch";

interface FilterSettingDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSave: () => void;
}

function isValidGlob(pattern: string): boolean {
  if (!pattern || pattern.trim().length === 0) return false;

  try {
    // Minimatchインスタンスを作成してパターンを検証
    new Minimatch(pattern);
    return true;
  } catch {
    return false;
  }
}

const PatternInput = memo(function PatternInput({
  value,
  onChange,
  onAdd,
  placeholder,
}: {
  value: string;
  onChange: (value: string) => void;
  onAdd: () => void;
  placeholder: string;
}) {
  return (
    <div className="flex gap-2 mb-2">
      <Input
        placeholder={placeholder}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onKeyDown={(e) => e.key === "Enter" && onAdd()}
      />
      <Button onClick={onAdd} size="icon">
        <Plus className="h-4 w-4" />
      </Button>
    </div>
  );
});

const PatternList = memo(function PatternList({
  patterns,
  type,
  onRemove,
}: {
  patterns: string[];
  type: "exclude" | "include";
  onRemove: (pattern: string, type: "exclude" | "include") => void;
}) {
  return (
    <ScrollArea className="h-[150px] rounded-md border p-4">
      <div className="flex flex-wrap gap-2">
        {patterns.map((pattern) => (
          <Badge
            key={pattern}
            variant="secondary"
            className="flex items-center gap-1"
          >
            {pattern}
            <button
              onClick={() => onRemove(pattern, type)}
              className="ml-1 hover:text-destructive"
              aria-label={`Remove ${pattern} pattern`}
            >
              <X className="h-3 w-3" />
            </button>
          </Badge>
        ))}
      </div>
    </ScrollArea>
  );
});

const FileSizeInput = memo(function FileSizeInput({
  value,
  onChange,
}: {
  value: number;
  onChange: (value: number) => void;
}) {
  return (
    <Input
      type="number"
      value={value}
      onChange={(e) => onChange(Number(e.target.value))}
      className="max-w-xs"
      placeholder="Maximum file size (MB)"
    />
  );
});

export function FilterSettingDialog({
  open,
  onOpenChange,
  onSave,
}: FilterSettingDialogProps) {
  const { data: filterSettings } = useGetSettings();
  const { toast } = useToast();
  const { mutate: updateSettings } = useUpdateSettings();

  const [excludePatterns, setExcludePatterns] = useState<string[]>([]);
  const [includePatterns, setIncludePatterns] = useState<string[]>([]);
  const [maxFileSize, setMaxFileSize] = useState<number>(10);
  const [newExcludePattern, setNewExcludePattern] = useState("");
  const [newIncludePattern, setNewIncludePattern] = useState("");

  useEffect(() => {
    if (filterSettings) {
      setExcludePatterns(filterSettings.excludePatterns || []);
      setIncludePatterns(filterSettings.includePatterns || []);
    }
  }, [filterSettings]);

  const showErrorToast = useCallback(() => {
    toast({
      title: "Invalid Pattern",
      description: "Pattern is empty, invalid or already exists.",
      variant: "destructive",
    });
  }, [toast]);

  const addPattern = useCallback(
    (type: "exclude" | "include") => {
      if (type === "exclude") {
        const trimmedPattern = newExcludePattern.trim();
        if (
          trimmedPattern &&
          isValidGlob(trimmedPattern) &&
          !excludePatterns.includes(trimmedPattern)
        ) {
          setExcludePatterns((prev) => [...prev, trimmedPattern]);
          setNewExcludePattern("");
        } else {
          showErrorToast();
        }
      } else {
        const trimmedPattern = newIncludePattern.trim();
        if (
          trimmedPattern &&
          isValidGlob(trimmedPattern) &&
          !includePatterns.includes(trimmedPattern)
        ) {
          setIncludePatterns((prev) => [...prev, trimmedPattern]);
          setNewIncludePattern("");
        } else {
          showErrorToast();
        }
      }
    },
    [
      newExcludePattern,
      newIncludePattern,
      excludePatterns,
      includePatterns,
      showErrorToast,
    ]
  );

  const removePattern = useCallback(
    (pattern: string, type: "exclude" | "include") => {
      if (type === "exclude") {
        setExcludePatterns((prev) => prev.filter((p) => p !== pattern));
      } else {
        setIncludePatterns((prev) => prev.filter((p) => p !== pattern));
      }
    },
    []
  );

  const handleSave = useCallback(async () => {
    updateSettings(
      {
        includePatterns,
        excludePatterns,
      },
      {
        onSuccess: () => {
          toast({
            title: "Settings updated",
            variant: "default",
            description: "Your settings have been updated successfully",
          });
          onSave();
          onOpenChange(false);
        },
      }
    );
  }, [
    includePatterns,
    excludePatterns,
    updateSettings,
    toast,
    onSave,
    onOpenChange,
  ]);

  const handleExcludePatternChange = useCallback((value: string) => {
    setNewExcludePattern(value);
  }, []);

  const handleIncludePatternChange = useCallback((value: string) => {
    setNewIncludePattern(value);
  }, []);

  const handleMaxFileSizeChange = useCallback((value: number) => {
    setMaxFileSize(value);
  }, []);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Filter Settings</DialogTitle>
          <DialogDescription></DialogDescription>
        </DialogHeader>
        <div className="space-y-8">
          <div className="space-y-4">
            <div>
              <h3 className="text-lg font-medium">Exclude Patterns</h3>
              <p className="text-sm text-muted-foreground">
                Specify patterns for files and directories to exclude from
                processing
              </p>
            </div>
            <PatternInput
              value={newExcludePattern}
              onChange={handleExcludePatternChange}
              onAdd={() => addPattern("exclude")}
              placeholder="Add new exclude pattern (e.g. *.log)"
            />
            <PatternList
              patterns={excludePatterns}
              type="exclude"
              onRemove={removePattern}
            />
          </div>

          <div className="space-y-4">
            <div>
              <h3 className="text-lg font-medium">Include Patterns</h3>
              <p className="text-sm text-muted-foreground">
                Specify patterns for files that should always be included
              </p>
            </div>
            <PatternInput
              value={newIncludePattern}
              onChange={handleIncludePatternChange}
              onAdd={() => addPattern("include")}
              placeholder="Add new include pattern (e.g. *.md)"
            />
            <PatternList
              patterns={includePatterns}
              type="include"
              onRemove={removePattern}
            />
          </div>

          <div className="space-y-4">
            <div>
              <h3 className="text-lg font-medium">File Size Limit</h3>
              <p className="text-sm text-muted-foreground">
                Set the maximum file size that will be processed (in MB)
              </p>
            </div>
            <FileSizeInput
              value={maxFileSize}
              onChange={handleMaxFileSizeChange}
            />
          </div>

          <Button onClick={handleSave} className="w-full">
            Save Settings
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

----
frontend/src/pages/RepositoryDetails/components/TopFilesChart.tsx
/* eslint-disable @typescript-eslint/no-explicit-any */
import { FileData } from "@/types";
import { formatNumber } from "@/utils/formatters";
import { Bar } from "react-chartjs-2";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

// 必要な構成要素を登録
ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
);

interface TopFilesChartParams {
  fileData: FileData[];
}

function TopFilesChart({ fileData }: TopFilesChartParams) {
  // Sort fileData by tokens in descending order and take top 20
  const sortedFiles = [...fileData]
    .sort((a, b) => b.tokens - a.tokens)
    .slice(0, 20);

  const labels = sortedFiles.map((file) => file.name);
  const data = sortedFiles.map((file) => file.tokens);

  const chartData = {
    labels: labels,
    datasets: [
      {
        label: "Context Length",
        data: data,
        backgroundColor: "#36A2EB",
        borderColor: "#2693e6",
        borderWidth: 1,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          label: function (context: any) {
            return `${formatNumber(context.raw)} tokens`;
          },
        },
      },
    },
    scales: {
      x: {
        title: { display: true, text: "File Names" },
        ticks: {
          autoSkip: false,
          maxRotation: 45,
          minRotation: 45,
        },
      },
      y: {
        title: { display: true, text: "Context Length" },
        ticks: { beginAtZero: true },
      },
    },
  };

  return (
    <Card className="p-2">
      <CardHeader className="p-4">
        <CardTitle>Top 20 Files by Context Length</CardTitle>
      </CardHeader>
      <CardContent className="p-4">
        <div className="chart-container">
          <Bar data={chartData} options={chartOptions as any} />
        </div>
      </CardContent>
    </Card>
  );
}

export default TopFilesChart;

----
frontend/src/pages/RepositoryDetails/components/Report.tsx
import FileTypesChart from "./FileTypesChart";
import DigestStatistics from "./DigestStatistics";
import TopFilesChart from "./TopFilesChart";
import AllFilesTable from "./AllFilesTable";
import { Summary } from "@/types";
interface ReportParams {
  summary: Summary;
  author: string;
  name: string;
}

function Report({ summary, author, name }: ReportParams) {
  const { fileTypes, fileData } = summary;

  return (
    <div>
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
        <FileTypesChart fileTypes={fileTypes} />
        <DigestStatistics summary={summary} />
      </div>

      <TopFilesChart fileData={fileData} />
      <AllFilesTable fileData={fileData} author={author} name={name} />
    </div>
  );
}

export default Report;

----
frontend/src/pages/RepositoryDetails/components/FileTypesChart.tsx
import { Pie } from "react-chartjs-2";
import { Chart as ChartJS, ArcElement, Tooltip, Legend } from "chart.js";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardDescription,
} from "@/components/ui/card";

ChartJS.register(ArcElement, Tooltip, Legend);

type FileTypeAggregation = {
  extension: string;
  count: number;
  tokens: number;
};

interface FileTypesChartParams {
  fileTypes: FileTypeAggregation[];
}

function FileTypesChart({ fileTypes }: FileTypesChartParams) {
  // tokens (context length) で降順ソート
  const sortedFileTypes = [...fileTypes].sort((a, b) => b.tokens - a.tokens);

  const labels = sortedFileTypes.map((fileType) => fileType.extension);
  const data = sortedFileTypes.map((fileType) => fileType.tokens);

  const chartData = {
    labels: labels,
    datasets: [
      {
        data: data,
        backgroundColor: [
          "#36A2EB",
          "#4BC0C0",
          "#FFCE56",
          "#FF6384",
          "#FF9F40",
          "#9966FF",
          "#FF6384",
          "#FFCE56",
          "#4BC0C0",
          "#36A2EB",
        ],
      },
    ],
  };

  return (
    <Card className="shadow-md rounded-lg p-2">
      <CardHeader className="p-4">
        <CardTitle>Context length distribution by file type</CardTitle>
        <CardDescription>
          Total context length for each file type, sorted by size
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="chart-container">
          <Pie data={chartData} />
        </div>
      </CardContent>
    </Card>
  );
}

export default FileTypesChart;

----
frontend/src/pages/RepositoryDetails/components/DigestStatistics.tsx
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableRow } from "@/components/ui/table";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { formatNumber } from "@/utils/formatters";

type FileTypeAggregation = {
  extension: string;
  count: number;
  tokens: number;
};

type Summary = {
  repository: string;
  totalFiles: number;
  totalSizeKb: number;
  averageFileSizeKb: number;
  maxFileSizeKb: number;
  minFileSizeKb: number;
  fileTypes: FileTypeAggregation[];
  contextLength: number;
};

interface DigestStatisticsParams {
  summary: Summary;
}

function DigestStatistics({ summary }: DigestStatisticsParams) {
  return (
    <Card className="p-2">
      <CardHeader className="p-4">
        <CardTitle>Digest Statistics</CardTitle>
      </CardHeader>
      <CardContent className="p-4">
        <Table className="w-full">
          <TableBody>
            <TableRow>
              <TableCell className="font-semibold">
                Context Length (GPT-4o)
              </TableCell>
              <TableCell className="relative">
                <span
                  className={
                    summary.contextLength > 128000
                      ? "text-destructive"
                      : "text-muted-foreground"
                  }
                >
                  {formatNumber(summary.contextLength)}
                </span>
                {summary.contextLength > 128000 && (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span className="text-red-600 underline cursor-help ml-2">
                        ?
                      </span>
                    </TooltipTrigger>
                    <TooltipContent className="bg-gray-800 text-white text-sm rounded-md shadow-md px-4 py-2 w-64">
                      The context length exceeds the limit of 128,000 for
                      GPT-4o. Consider reducing the content or splitting it into
                      smaller chunks to fit within the limit.
                    </TooltipContent>
                  </Tooltip>
                )}
              </TableCell>
            </TableRow>
            <TableRow>
              <TableCell className="font-semibold">Total Files</TableCell>
              <TableCell>{formatNumber(summary.totalFiles)}</TableCell>
            </TableRow>
            <TableRow>
              <TableCell className="font-semibold">Total Size</TableCell>
              <TableCell>{formatNumber(summary.totalSizeKb)} KB</TableCell>
            </TableRow>
            <TableRow>
              <TableCell className="font-semibold">Average File Size</TableCell>
              <TableCell>
                {formatNumber(summary.averageFileSizeKb)} KB
              </TableCell>
            </TableRow>
            <TableRow>
              <TableCell className="font-semibold">Max File Size</TableCell>
              <TableCell>{formatNumber(summary.maxFileSizeKb)} KB</TableCell>
            </TableRow>
            <TableRow>
              <TableCell className="font-semibold">Min File Size</TableCell>
              <TableCell>{formatNumber(summary.minFileSizeKb)} KB</TableCell>
            </TableRow>
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}

export default DigestStatistics;

----
frontend/src/services/settings/queries.ts
import client from "@/lib/api/client";
import { components } from "@/lib/api/schema";
import { Settings } from "@/types";
import { useQuery } from "@tanstack/react-query";

function toSettings(data: components["schemas"]["Settings"]): Settings {
  return {
    includePatterns: data.include_files,
    excludePatterns: data.exclude_files,
  };
}

function useGetSettings() {
  return useQuery({
    queryKey: ["settings"],
    initialData: {
      includePatterns: [],
      excludePatterns: [],
    },
    queryFn: async () => {
      const response = await client.GET("/settings");
      if (!response.data) {
        throw new Error("Failed to fetch settings");
      }
      return toSettings(response.data);
    },
  });
}

export { useGetSettings };

----
frontend/src/services/settings/mutations.ts
import client from "@/lib/api/client";
import { useMutation } from "@tanstack/react-query";
import { Settings } from "@/types";
import { useQueryClient } from "@tanstack/react-query";
import { components } from "@/lib/api/schema";

function useUpdateSettings() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (settings: Settings) =>
      client.PUT("/settings", {
        body: {
          include_files: settings.includePatterns,
          exclude_files: settings.excludePatterns,
        },
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["settings"] });
    },
  });
}

function toSettings(data: components["schemas"]["Settings"]): Settings {
  return {
    includePatterns: data.include_files,
    excludePatterns: data.exclude_files,
  };
}

type ExcludeFilesParams = {
  author: string;
  name: string;
  paths: string[];
};
function useExcludeFiles() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (params: ExcludeFilesParams) => {
      let settings = queryClient.getQueryData<Settings>(["settings"]);
      if (!settings) {
        const response = await client.GET("/settings");
        if (!response.data) {
          throw new Error("Failed to fetch settings");
        }
        settings = toSettings(response.data);
      }
      await client.PUT("/settings", {
        body: {
          include_files: settings.includePatterns,
          exclude_files: [...settings.excludePatterns, ...params.paths],
        },
      });
    },
    onSuccess: (_, params) => {
      queryClient.invalidateQueries({ queryKey: ["settings"] });
      queryClient.invalidateQueries({
        queryKey: ["summary", params.author, params.name],
      });
    },
  });
}

export { useUpdateSettings, useExcludeFiles };

----
frontend/src/services/digest/mutations.ts
import { useMutation } from "@tanstack/react-query";

interface GenerateDigestParams {
  author: string;
  repositoryName: string;
}

export const useGenerateDigest = () => {
  return useMutation({
    mutationFn: async (params: GenerateDigestParams) => {
      // なぜかopenapi fetchではダウンロードできない
      const response = await fetch(`http://localhost:8000/digest`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          url: `https://github.com/${params.author}/${params.repositoryName}`,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || "Failed to generate digest");
      }

      // Get the blob from response
      const blob = await response.blob();
      // Create download URL
      const downloadUrl = window.URL.createObjectURL(blob);

      // Trigger download
      const link = document.createElement("a");
      link.href = downloadUrl;
      link.download = getDefaultFilename(params.author, params.repositoryName);
      document.body.appendChild(link);
      link.click();

      // Cleanup
      document.body.removeChild(link);
      window.URL.revokeObjectURL(downloadUrl);

      return { success: true };
    },
  });
};

const getDefaultFilename = (author: string, repositoryName: string): string => {
  const repoName = repositoryName;
  return `${author}_${repoName}_digest.txt`;
};

----
frontend/src/services/repositories/queries.ts
import { useQuery, useQueryClient } from "@tanstack/react-query";
import client from "@/lib/api/client";
import { Repository } from "@/types";
import { components } from "@/lib/api/schema";

type RepositoryResponse = components["schemas"]["Repository"];
function toRepository(r: RepositoryResponse): Repository {
  return {
    id: r.id,
    name: r.name,
    author: r.author,
    path: r.path,
    updatedAt: new Date(r.updated_at),
    branch: r.branch,
    url: r.url,
    size: r.size,
  } satisfies Repository;
}

const useGetRepositories = () => {
  return useQuery<Repository[]>({
    queryKey: ["repositories"],
    queryFn: async () => {
      const response = await client.GET("/repositories");
      return (response.data ?? []).map(toRepository);
    },
  });
};

type GetRepositoryByIdParams = {
  author?: string;
  name?: string;
};

const useGetRepositoryById = (params: GetRepositoryByIdParams) => {
  return useQuery<Repository | null>({
    queryKey: ["repository", params.author, params.name],
    enabled: !!params.author && !!params.name,
    queryFn: async () => {
      const response = await client.GET(
        "/repositories/{author}/{repository_name}",
        {
          params: {
            path: {
              author: params.author!,
              repository_name: params.name!,
            },
          },
        }
      );
      if (!response.data) {
        return null;
      }
      return toRepository(response.data);
    },
  });
};

type PrefetchRepositoryByIdParams = {
  author: string;
  name: string;
};
const usePrefetchRepositoryById = (params: PrefetchRepositoryByIdParams) => {
  const queryClient = useQueryClient();
  const prefetch = () => {
    queryClient.prefetchQuery({
      queryKey: ["repository", params.author, params.name],
      staleTime: 1000 * 60 * 5, // 5 minutes
      queryFn: async () => {
        const response = await client.GET(
          "/repositories/{author}/{repository_name}",
          {
            params: {
              path: {
                author: params.author,
                repository_name: params.name,
              },
            },
          }
        );
        return response.data ? toRepository(response.data) : null;
      },
    });
  };
  return prefetch;
};

export { useGetRepositories, useGetRepositoryById, usePrefetchRepositoryById };

----
frontend/src/services/repositories/mutations.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import client from "@/lib/api/client";
import { extractAuthorAndNameFromUrl } from "@/lib/utils";

type CloneRepositoryParams = {
  repositoryIdOrUrl: string;
};

const useCloneRepository = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation({
    mutationFn: (params: CloneRepositoryParams) => {
      return client.POST("/repositories", {
        body: {
          url: params.repositoryIdOrUrl,
        },
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["repositories"] });
    },
  });

  return mutation;
};

type DeleteRepositoryParams = {
  repositoryIdOrUrl: string;
};

const useDeleteRepository = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation({
    mutationFn: (params: DeleteRepositoryParams) => {
      return client.DELETE("/repositories", {
        body: {
          url: params.repositoryIdOrUrl,
        },
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["repositories"] });
    },
  });

  return mutation;
};

type UpdateRepositoryParams = {
  repositoryIdOrUrl?: string;
};

const useUpdateRepository = () => {
  const queryClient = useQueryClient();
  const mutation = useMutation({
    mutationFn: (params: UpdateRepositoryParams) => {
      return client.PUT("/repositories", {
        body: {
          url: params.repositoryIdOrUrl,
        },
      });
    },
    onSuccess: (_, params: UpdateRepositoryParams) => {
      queryClient.invalidateQueries({ queryKey: ["repositories"] });
      const { author, name } = extractAuthorAndNameFromUrl(
        params.repositoryIdOrUrl!
      ) ?? {};
      if (author && name) {
        queryClient.invalidateQueries({ queryKey: ["summary", author, name] });
      }
    },
  });

  return mutation;
};

export { useCloneRepository, useDeleteRepository, useUpdateRepository };

----
frontend/src/services/summary/queries.ts
import client from "@/lib/api/client";
import { components } from "@/lib/api/schema";
import { Summary } from "@/types";
import { useQuery } from "@tanstack/react-query";

function toSummary(response: components["schemas"]["Summary"]): Summary {
  return {
    repository: response.repository,
    totalFiles: response.total_files,
    totalSizeKb: response.total_size_kb,
    averageFileSizeKb: response.average_file_size_kb,
    maxFileSizeKb: response.max_file_size_kb,
    minFileSizeKb: response.min_file_size_kb,
    fileTypes: response.file_types.map(
      (fileType: components["schemas"]["FileType"]) => ({
        extension: fileType.extension,
        count: fileType.count,
        tokens: fileType.tokens,
      })
    ),
    contextLength: response.context_length,
    fileData: response.file_data.map(
      (file: components["schemas"]["FileData"]) => ({
        name: file.name,
        path: file.path,
        extension: file.extension,
        tokens: file.tokens,
      })
    ),
  };
}

type GetSummaryParams = { author?: string; name?: string };
function useGetSummary(params: GetSummaryParams) {
  const query = useQuery({
    queryKey: ["summary", params.author, params.name],
    enabled: !!params.author && !!params.name,
    staleTime: Infinity,
    queryFn: async () => {
      const response = await client.GET(
        `/{author}/{repository_name}/summary`,
        {
          params: {
            path: {
              author: params.author!,
              repository_name: params.name!,
            },
          },
        }
      );
      console.log(response);
      return response?.data ? toSummary(response.data) : null;
    },
  });
  return query;
}

export { useGetSummary };

----
frontend/src/services/summary/mutations.ts

----
repo_tool/core/digest.py
import concurrent.futures
from concurrent.futures import Future
from io import StringIO
from pathlib import Path
from typing import List, Optional, TypeVar

from repo_tool.core.contants import DIGEST_DIR
from repo_tool.core.filter import filter_files_in_repo
from repo_tool.core.summary import generate_summary

T = TypeVar("T")  # Define a type variable for the Future's return type


def generateSummaryAndReport(repo_path: Path, file_list: List[Path]) -> None:
    summary = generate_summary(repo_path, file_list)
    summary.generate_report()


def generate_digest(repo_path: Path, prompt: Optional[str] = None) -> None:
    try:
        file_list = filter_files_in_repo(repo_path, prompt)
        if file_list:
            print("Generating summary and digest...")
            with concurrent.futures.ThreadPoolExecutor() as executor:
                # Create properly typed futures list
                futures: List[Future[None]] = [
                    executor.submit(store_result_to_file, repo_path, file_list),
                    executor.submit(generateSummaryAndReport, repo_path, file_list),
                ]
                # Wait for all tasks to complete
                concurrent.futures.wait(futures)
        else:
            print("Failed to generate digest.")
    except Exception as e:
        print("Error:", e)


def generate_digest_content(repo_path: Path, filtered_files: List[Path]) -> str:
    """
    Generates digest content as a string from the filtered files in the repository.
    """
    if not filtered_files:
        return "No matching files found."

    output = StringIO()

    # Add preamble
    output.write(
        "The following text represents the contents of the repository.\n"
        "Each section begins with ----, followed by the file path and name.\n"
        "A file list is provided at the beginning. End of repository content is marked by --END--.\n\n"
    )

    # ファイルのみを処理
    file_list = [f for f in filtered_files if f.is_file()]

    # Add file contents
    for file_path in file_list:
        try:
            relative_path = file_path.relative_to(repo_path)
            output.write("----\n")  # Section divider
            output.write(f"{relative_path}\n")  # File path

            # ファイルを1行ずつ読み込んで処理
            with file_path.open("r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    output.write(line)
            output.write("\n")

        except Exception as e:
            # Log the error and continue
            relative_path = file_path.relative_to(repo_path)
            output.write("----\n")
            output.write(f"{relative_path}\n")
            output.write(f"Error reading file: {e}\n\n")

    output.write("--END--")
    return output.getvalue()


def store_result_to_file(repo_path: Path, filtered_files: List[Path]) -> None:
    """
    Generates a digest from the filtered files and stores it in a file.
    """
    if not filtered_files:
        print("No matching files found.")
        return

    # 出力ディレクトリとファイルパスの設定
    output_dir = Path(DIGEST_DIR)
    output_dir.mkdir(exist_ok=True)
    output_path = output_dir / f"{repo_path.name}.txt"

    digest_content = generate_digest_content(repo_path, filtered_files)

    with open(output_path, "w", encoding="utf-8") as output:
        output.write(digest_content)

----
repo_tool/core/contants.py
DIGEST_DIR = "digests"

----
repo_tool/core/__init__.py
"""
Core functionality for repo-digest-tool
"""

from .contants import DIGEST_DIR
from .digest import generate_digest
from .filter import filter_files_in_repo, get_filter_settings
from .github import GitHub, Repository
from .llm import filter_files_with_llm
from .logger import log_error
from .summary import generate_summary

# 他のモジュールや関数を必要に応じてインポート
__all__ = [
    "log_error",
    "generate_summary",
    "filter_files_with_llm",
    "filter_files_in_repo",
    "generate_digest",
    "DIGEST_DIR",
    "GitHub",
    "Repository",
    "get_filter_settings",
]

----
repo_tool/core/llm.py
import asyncio
import os
from pathlib import Path
from typing import Any, List

from dotenv import load_dotenv
from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

# Load environment variables
load_dotenv(override=True)

# Configuration constants
default_model = "gpt-4o-mini"
default_temperature = 0
defatult_batch_size = 20

# LLM prompt template
template = """
Filter files from a GitHub repository based on relevance by excluding irrelevant files such as CI/CD, configuration files, binary files, and compiled files.

You will receive a list of file paths and their associated sizes. Your task is to assess each file path and determine if it is relevant for creating a digest suitable for input into ChatGPT. Exclude files that are commonly not useful for summaries or understanding, such as CI/CD, configuration files, binary files, and compiled files.

# Steps

1. **Identify File Types**: Examine the file paths and identify the types of files they represent.
2. **Determine Relevance**: Use the following guidelines to determine if a file should be excluded:
   - Exclude files typically irrelevant for summaries:
     - Continuous Integration/Continuous Deployment (CI/CD) files (e.g., `.github/workflows/`, `.gitlab-ci.yml`)
     - Configuration files (e.g., `*.config`, `config.yaml`)
     - Binary files (e.g., `*.exe`, `*.bin`, `*.dll`)
     - Compiled files (e.g., `*.class`, `*.o`, `*.pyc`)
     - Other non-source code files that do not contribute to code understanding (e.g., `*.log`, `*.tmp`)
3. **Filter Files**: Create a list that only includes the files deemed relevant based on the above criteria.

# Notes

- Only focus on the file path suffix in determining file type.
- Consider common conventions for CI/CD and configuration files.
- This process is to ensure only the potentially most relevant files for understanding the repository's code are included.
- Do not modify the file paths in the output in any way.

# Input
{file_info}

# User Prompt
{user_prompt}
"""


# Models
class FileInfo(BaseModel):
    path: str = Field(description="File path")


class FilteredFiles(BaseModel):
    files: List[FileInfo] = Field(
        description="Filtered file list that is suitable for ChatGPT"
    )


def split_into_batches(items: List[Any], batch_size: int) -> List[List[Any]]:
    """
    Split a list into smaller batches.
    """
    return [items[i : i + batch_size] for i in range(0, len(items), batch_size)]


llm_chain = None
if os.getenv("OPENAI_API_KEY"):
    llm = ChatOpenAI(
        temperature=default_temperature,
        model=default_model,
    ).with_structured_output(FilteredFiles)
    prompt_template = ChatPromptTemplate.from_template(template)
    llm_chain = prompt_template | llm


async def filter_files_batch(file_batch: List[Path], prompt: str) -> List[Path]:
    """
    Filter files in a single batch using the LLM chain.
    """
    file_info = [
        {"path": str(file), "size": os.path.getsize(file)}
        for file in file_batch
        if file.is_file()
    ]
    if not llm_chain:
        raise RuntimeError("OPENAI_API_KEY is not set.")
    # Invoke LLM chain synchronously
    result = await llm_chain.ainvoke(
        {
            "file_info": "\n".join(
                [f"{file['path']}: {file['size']} bytes" for file in file_info]
            ),
            "user_prompt": prompt,
        }
    )
    if not hasattr(result, "files"):
        return []
    return [Path(file_info.path) for file_info in result.files]


async def filter_files_with_llm_in_batch(
    file_list: List[Path], prompt: str, batch_size: int = defatult_batch_size
) -> List[Path]:
    """
    Filter a list of files in batches using an LLM.
    """
    print("Using LLM to filter files in parallel...")

    # Split file list into batches
    batches = split_into_batches(file_list, batch_size)

    # Process each batch in parallel
    tasks = [
        asyncio.create_task(filter_files_batch(batch, prompt)) for batch in batches
    ]
    results = await asyncio.gather(*tasks)

    # Combine results
    filtered_files = [file for batch_result in results for file in batch_result]

    print(
        f"Finished filtering {len(file_list)} files with LLM in {len(batches)} batches."
    )
    return filtered_files


def filter_files_with_llm(
    file_list: List[Path], prompt: str, batch_size: int = defatult_batch_size
) -> List[Path]:
    """
    Synchronous wrapper for filtering files with LLM in batches.
    """
    return asyncio.run(filter_files_with_llm_in_batch(file_list, prompt, batch_size))

----
repo_tool/core/logger.py
import logging

logging.basicConfig(
    filename="repo_tool.log",
    level=logging.ERROR,
    format="%(asctime)s - %(levelname)s - %(message)s",
)


def log_error(e: Exception) -> None:
    logging.error(str(e))

----
repo_tool/core/summary.py
import asyncio
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

import aiofiles
import tiktoken
from jinja2 import Environment, FileSystemLoader

from repo_tool.core.contants import DIGEST_DIR

data_size = 20
precision = 2
encoding = tiktoken.get_encoding("o200k_base")


@dataclass
class FileInfo:
    """ファイル処理に必要な情報を保持するデータクラス"""

    file_path: Path
    repo_path: Path


@dataclass
class FileType:
    extension: str
    count: int
    tokens: int


@dataclass
class FileStats:
    file_count: int
    total_size: float
    average_size: float
    max_size: float
    min_size: float
    context_length: int
    extension_tokens: List[FileType] = field(default_factory=list)


@dataclass
class FileData:
    name: str
    path: str
    extension: str
    tokens: int


@dataclass
class Summary:
    repository: str
    total_files: int
    total_size_kb: float
    average_file_size_kb: float
    max_file_size_kb: float
    min_file_size_kb: float
    file_types: List[FileType]
    context_length: int
    file_data: List[FileData]

    def generate_report(self, data_size: int = 20) -> None:
        """
        HTMLレポートを生成して保存する
        """
        # Jinja2 環境を設定
        env = Environment(loader=FileSystemLoader("templates"))
        env.filters["format_number"] = format_number
        template = env.get_template("report.html")

        # ファイルタイプをトークン数でソート
        sorted_file_types = sorted(
            self.file_types, key=lambda x: x.tokens, reverse=True
        )[:data_size]

        html_content = template.render(
            repo_name=self.repository,
            summary=self,
            file_types_labels=[ft.extension for ft in sorted_file_types],
            file_types_data=[ft.tokens for ft in sorted_file_types],
            file_sizes_labels=[item.name for item in self.file_data[:data_size]],
            file_sizes_data=[item.tokens for item in self.file_data[:data_size]],
            file_sizes_paths=[item.path for item in self.file_data[:data_size]],
            all_files=self.file_data,
        )

        # HTMLレポートを保存
        report_path = f"digests/{self.repository}_report.html"
        with open(report_path, "w", encoding="utf-8") as f:
            f.write(html_content)
        print(f"Report saved to {report_path}")


# カスタムフィルターを定義
def format_number(value: int | float | str) -> str:
    """数値をカンマ区切りにフォーマット"""
    if isinstance(value, (int, float)):
        return f"{value:,}"  # カンマ区切り
    return value


def generate_summary(
    repo_path: Path,
    file_list: List[Path],
) -> Summary:
    """
    ファイル統計のサマリーレポートを生成する
    """
    if not os.path.exists(DIGEST_DIR):
        os.makedirs(DIGEST_DIR, exist_ok=True)
    # レポートの生成
    # ファイルサイズデータの取得
    file_size_data = []

    for file_path in file_list:
        # 相対パスの処理を修正
        if isinstance(file_path, str):
            file_path = Path(file_path)

        try:
            relative_path = file_path.relative_to(repo_path)
        except ValueError:
            # すでに相対パスの場合はそのまま使用
            relative_path = file_path

        full_path = repo_path / relative_path
        if full_path.is_file():
            try:
                with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()
                    tokens = len(encoding.encode(content))

                file_size_data.append(
                    FileData(
                        name=relative_path.name,
                        path=str(relative_path),
                        extension=relative_path.suffix.lower() or "no_extension",
                        tokens=tokens,
                    )
                )
            except Exception as e:
                print(f"Error processing file {relative_path}: {e}")
                continue
    # Sort by token count
    file_size_data.sort(key=lambda x: x.tokens, reverse=True)

    file_infos = [FileInfo(Path(f), repo_path) for f in file_list]
    # 非同期処理の実行と結果の取得
    stats = asyncio.run(process_files(file_infos))

    # サマリーの生成
    summary = Summary(
        repository=repo_path.name,
        total_files=stats.file_count,
        total_size_kb=round(stats.total_size, precision),
        average_file_size_kb=round(stats.average_size, precision),
        max_file_size_kb=round(stats.max_size, precision),
        min_file_size_kb=round(stats.min_size, precision),
        file_types=stats.extension_tokens,
        context_length=stats.context_length,
        file_data=file_size_data,
    )
    return summary


async def process_files(file_infos: List[FileInfo]) -> FileStats:
    """
    全ファイルの非同期処理と集計を行う
    """
    extension_data: Dict[str, Dict[str, int]] = {}  # 一時的な集計用辞書
    total_size = 0
    file_sizes = []
    context_length = 0
    processed_files = []

    tasks = [process_single_file(file_info) for file_info in file_infos]
    results = await asyncio.gather(*tasks)

    for result in results:
        if result is None:
            continue

        processed_files.append(result["path"])
        total_size += result["size"]
        context_length += result["tokens"]
        file_sizes.append(result["size"])

        ext = result["extension"]
        if ext not in extension_data:
            extension_data[ext] = {"count": 0, "tokens": 0}
        extension_data[ext]["count"] += 1
        extension_data[ext]["tokens"] += result["tokens"]

    # 辞書からFileTypeのリストに変換
    extension_tokens = [
        FileType(extension=ext, count=data["count"], tokens=data["tokens"])
        for ext, data in extension_data.items()
    ]

    file_count = len(processed_files)
    return FileStats(
        file_count=file_count,
        total_size=total_size,
        average_size=total_size / file_count if file_count > 0 else 0,
        max_size=max(file_sizes, default=0),
        min_size=min(file_sizes, default=0),
        extension_tokens=extension_tokens,
        context_length=context_length,
    )


async def process_single_file(file_info: FileInfo) -> Optional[Dict[str, Any]]:
    """
    単一ファイルの非同期処理を行う補助関数
    """
    try:
        relative_path = str(file_info.file_path.relative_to(file_info.repo_path))

        async with aiofiles.open(
            file_info.file_path, "r", encoding="utf-8", errors="ignore"
        ) as f:
            content = await f.read()
            tokens = len(encoding.encode(content))

        file_size = file_info.file_path.stat().st_size / 1024  # bytes to KB
        ext = file_info.file_path.suffix.lower() or "no_extension"

        return {
            "path": relative_path,
            "size": file_size,
            "tokens": tokens,
            "extension": ext,
        }
    except Exception as e:
        print(f"Error processing file {file_info.file_path}: {e}")
        return None

----
repo_tool/core/filter.py
import fnmatch
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from repo_tool.core.llm import filter_files_with_llm
from repo_tool.core.logger import log_error


def get_all_files(repo_path: Path, ignore_patterns: List[str]) -> List[Path]:
    try:
        all_files = []
        for path in repo_path.rglob("*"):
            if not should_ignore(path, repo_path, ignore_patterns):
                all_files.append(path)
        return all_files
    except Exception as e:
        log_error(e)
        raise RuntimeError(f"Error while retrieving files from {repo_path}: {e}") from e


def should_ignore(file_path: Path, repo_path: Path, ignore_patterns: List[str]) -> bool:
    """
    Checks if a file or directory matches any of the ignore patterns.
    """
    relative_path = str(file_path.relative_to(repo_path))
    for pattern in ignore_patterns:
        # Match directories and files explicitly
        if pattern.endswith("/") and file_path.is_dir():
            if fnmatch.fnmatch(relative_path + "/", pattern):
                return True
        elif fnmatch.fnmatch(relative_path, pattern):
            return True
    return False


def filter_files(
    all_files: List[Path],
    repo_path: Path,
    ignore_patterns: List[str],
    include_patterns: List[str],
) -> List[Path]:
    """
    Filters the files based on .gptignore and .gptinclude patterns.
    """
    filtered_files = []
    for file_path in all_files:
        if should_ignore(file_path, repo_path, ignore_patterns):
            continue

        relative_path = str(file_path.relative_to(repo_path))

        # Check if the file matches any include pattern
        include_match = any(
            fnmatch.fnmatch(relative_path, pattern) for pattern in include_patterns
        )

        # If include patterns are provided, skip files that do not match
        if include_patterns and not include_match:
            continue

        filtered_files.append(file_path)
    return filtered_files


def read_pattern_file(file_path: Path) -> List[str]:
    """
    Reads a pattern file and returns a list of patterns.
    Skips comments and empty lines.
    """
    pattern_list = []
    if file_path.exists():
        with file_path.open("r", encoding="utf-8") as pattern_file:
            for line in pattern_file:
                line = line.strip()
                if line and not line.startswith("#"):  # Skip comments and empty lines
                    pattern_list.append(line)
    return pattern_list


def filter_files_in_repo(repo_path: Path, prompt: Optional[str] = None) -> List[Path]:
    """
    Processes a repository using the .gptignore file to filter files.
    """
    if not repo_path.exists():
        raise ValueError(f"Repository path '{repo_path}' does not exist.")

    try:
        ignore_list = read_pattern_file(Path(".") / ".gptignore")
        include_list = read_pattern_file(Path(".") / ".gptinclude")
        # Get all files and filter based on extensions and .gptignore
        all_files = get_all_files(repo_path, ignore_list)
        filtered_files = filter_files(all_files, repo_path, ignore_list, include_list)
        if prompt:
            filtered_files = filter_files_with_llm(filtered_files, prompt)
        file_list = [file_path for file_path in filtered_files if file_path.is_file()]
        return file_list
    except Exception as e:
        log_error(e)
        raise RuntimeError(
            f"Error while processing repository '{repo_path}': {e}"
        ) from e


@dataclass
class FilterSettings:
    ignore_list: List[str]
    include_list: List[str]


def get_filter_settings() -> FilterSettings:
    ignore_list = read_pattern_file(Path(".") / ".gptignore")
    include_list = read_pattern_file(Path(".") / ".gptinclude")
    return FilterSettings(ignore_list, include_list)

----
repo_tool/core/github.py
import datetime
import os
import re
import shutil
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional
from urllib.parse import urlparse, urlunparse

from git import GitCommandError, Repo

from repo_tool.core.logger import log_error

REPO_DIR = "repositories"


@dataclass
class Repository:
    id: str
    url: str
    branch: Optional[str]
    path: Path
    updated_at: datetime.datetime
    name: str
    author: str
    size: int = 0

    def has_update(self) -> bool:
        repo = Repo(self.path)
        origin = repo.remotes.origin
        origin.fetch()
        local_commit = repo.head.commit.hexsha
        remote_commit: str = origin.refs[repo.active_branch.name].commit.hexsha
        return local_commit != remote_commit


class GitHub:
    def __init__(self, github_token: Optional[str] = None) -> None:
        self.github_token = github_token or os.getenv("GITHUB_TOKEN")

    def getByUrl(self, repo_url: str) -> Repository:
        repositories = self.list()
        for repository in repositories:
            if repository.url == repo_url:
                return repository
        raise ValueError(f"Repository not found: {repo_url}")

    def get(self, author: str, repository_name: str) -> Repository:
        repositories = self.list()
        for repository in repositories:
            if repository.author == author and repository.name == repository_name:
                return repository
        raise ValueError(f"Repository not found: {repository_name}")

    def clone(
        self, repo_url: str, branch: Optional[str] = None, force: bool = False
    ) -> Optional[Repository]:
        """
        Clone a repository.

        Args:
            repo_url (str): Repository URL.
            branch (Optional[str], optional): Branch to clone. Defaults to None.
            force (bool, optional): Force re-clone a repository. Defaults to False.

        Returns:
            Repository: Cloned repository

        Raises:
            e: GitCommandError
        """
        try:
            if GitHub.is_short_hand_url(repo_url):
                repo_url = GitHub.resolve_repo_url(repo_url)
            repo_path = self.get_repo_path(repo_url)
            if force:
                shutil.rmtree(repo_path, ignore_errors=True)
            if not os.path.exists(repo_path):
                Repo.clone_from(
                    url=self.replace_repo_url(repo_url),
                    to_path=repo_path,
                    depth=1,
                    branch=branch if branch else None,
                )
                # Extract author and repository name from the URL
                parsed_url = urlparse(repo_url)
                path_parts = parsed_url.path.strip("/").split("/")
                author = path_parts[0]
                repo_name = path_parts[1]

                return Repository(
                    id=f"{author}/{repo_name}",
                    url=repo_url,
                    branch=branch if branch else None,
                    path=repo_path,
                    updated_at=datetime.datetime.now(),
                    name=repo_name,
                    author=author,
                )
        except GitCommandError as e:
            log_error(e)
            raise e
        return None

    def remove(self, repo_url: str) -> None:
        """
        Delete a repository.

        Args:
            repo_url (str): The repository URL.
        """
        repo_path = self.get_repo_path(repo_url)
        shutil.rmtree(repo_path, ignore_errors=True)
        author_path = repo_path.parent

        # Check if the author directory exists before attempting to list its contents
        if os.path.exists(author_path) and not os.listdir(author_path):
            shutil.rmtree(author_path, ignore_errors=True)

    def clean(self) -> None:
        """
        Delete all repositories.
        """
        shutil.rmtree(REPO_DIR, ignore_errors=True)

    def update(self, repo_url: Optional[str] = None) -> List[Repository]:
        """
        Update one or all repositories.

        Args:
            repo_url (Optional[str]): Specific repository URL to update. If None, updates all repositories.

        Returns:
            List[Repository]: List of updated repositories
        """
        if repo_url:
            # Update single repository
            if GitHub.is_short_hand_url(repo_url):
                repo_url = GitHub.resolve_repo_url(repo_url)
            self._update_single(repo_url)
            return [repo for repo in self.list() if repo.url == repo_url]
        else:
            # Update all repositories in parallel
            repositories = self.list()
            repositories = [repo for repo in repositories if repo.has_update()]
            if not repositories:
                return repositories

            print(f"Updating {len(repositories)} repositories...")
            with ThreadPoolExecutor() as executor:
                futures = [
                    executor.submit(self._update_single, repo.url)
                    for repo in repositories
                ]
                for future in futures:
                    try:
                        future.result()  # Wait for each task to complete
                    except Exception as e:
                        print(f"Error updating repository: {e}")
            return repositories

    def _update_single(self, repo_url: str) -> None:
        """
        Update a single repository.
        """
        repo_path = self.get_repo_path(repo_url)
        if not os.path.exists(repo_path):
            raise ValueError(f"Repository does not exist: {repo_url}")
        repo = Repo(repo_path)
        repo.remotes.origin.pull()
        print(f"Updated repository: {repo_url}")

    def list(self) -> List[Repository]:
        """
        List all repositories.

        Returns:
            List[Repository]: List of repositories with their information
        """
        try:
            # Get only the repository root directories
            repo_paths = []
            if Path(REPO_DIR).exists():
                for author_dir in Path(REPO_DIR).iterdir():
                    if author_dir.is_dir():
                        for repo_dir in author_dir.iterdir():
                            if repo_dir.is_dir() and (repo_dir / ".git").exists():
                                repo_paths.append(repo_dir)

            repositories = []
            for repo_path in repo_paths:
                try:
                    repo = Repo(repo_path)
                    name = repo_path.name
                    author = repo_path.parent.name
                    size = repo_path.stat().st_size
                    repositories.append(
                        Repository(
                            id=f"{author}/{name}",
                            url=GitHub.remove_github_token(repo.remotes.origin.url),
                            branch=repo.active_branch.name,
                            path=repo_path,
                            updated_at=datetime.datetime.fromtimestamp(
                                repo.head.commit.committed_date
                            ),
                            name=name,
                            author=author,
                            size=size,
                        )
                    )
                except Exception as e:
                    log_error(e)
                    continue

            return repositories
        except Exception as e:
            log_error(e)
            return []

    @staticmethod
    def get_repo_path(url: str) -> Path:
        """
        Generate the local repository path from a GitHub URL.

        Args:
            url: GitHub repository URL

        Returns:
            Path object representing the local repository path

        Raises:
            ValueError: If the URL is invalid
        """
        if GitHub.is_short_hand_url(url):
            url = GitHub.resolve_repo_url(url)
        if not GitHub.is_valid_repo_url(url):
            raise ValueError("Invalid repository URL")

        # Extract author and repo name from URL
        # Remove .git extension if present
        match = re.match(r"https://github\.com/([^/]+)/([^/]+?)(?:\.git)?$", url)
        if not match:
            raise ValueError("Invalid repository URL")

        author, repo_name = match.groups()

        # Create path using the REPO_DIR constant
        return Path(REPO_DIR) / author / repo_name

    @staticmethod
    def is_valid_repo_url(url: str) -> bool:
        """
        Validate if the given URL is a valid GitHub repository URL.

        Args:
            url: URL to validate

        Returns:
            bool: True if URL is valid, False otherwise
        """
        # First check basic URL structure
        if not url.startswith("https://github.com/"):
            return False

        # Extract path after github.com/
        path = url.replace("https://github.com/", "")

        # Split into author and repo parts
        parts = path.split("/")
        if len(parts) != 2:
            return False

        author, repo = parts

        # Remove .git extension if present
        repo = repo.removesuffix(".git")

        # Check for security issues and valid characters
        if (
            ".." in author
            or ".." in repo  # Prevent directory traversal
            or "?" in author
            or "?" in repo  # Prevent query strings
            or "*" in author
            or "*" in repo  # Prevent wildcards
            or "[" in author
            or "[" in repo  # Prevent special characters
            or "]" in author
            or "]" in repo
            or "\\" in author
            or "\\" in repo
            or not author
            or not repo  # Ensure non-empty strings
            or not re.match(r"^[a-zA-Z0-9][-\w.]*$", author)  # Validate author format
            or not re.match(r"^[-\w.]+$", repo)  # Validate repo format
        ):
            return False

        return True

    @staticmethod
    def remove_github_token(repo_url: str) -> str:
        """
        Remove GitHub token from the repository URL if present.

        Args:
            repo_url (str): The repository URL.

        Returns:
            str: The sanitized repository URL.
        """
        parsed_url = urlparse(repo_url)
        if "@" in parsed_url.netloc:
            # Split on `@` to remove token part
            sanitized_netloc = parsed_url.netloc.split("@")[-1]
            sanitized_url = urlunparse(parsed_url._replace(netloc=sanitized_netloc))
            return sanitized_url
        return repo_url

    def replace_repo_url(self, repo_url: str) -> str:
        return repo_url.replace(
            "https://github.com/", f"https://{self.github_token}@github.com/"
        )

    def repo_exists(self, repo_url: str) -> bool:
        """
        Check if a repository exists.
        """
        repo_path = self.get_repo_path(repo_url)
        return os.path.exists(repo_path)

    def checkout(self, repo_path: Path, branch: Optional[str] = None) -> None:
        """
        Checkout a branch in a repository.
        """
        repo = Repo(repo_path)
        repo.git.checkout(branch if branch else repo.active_branch.name)

    @staticmethod
    def resolve_repo_url(repo_url: str) -> str:
        """
        Resolves a short-form GitHub repository URL (e.g., "author/repo-name")
        to a full URL (e.g., "https://github.com/author/repo-name").

        Args:
            repo_url (str): The short-form or full repository URL.

        Returns:
            str: The full repository URL.
        """
        if repo_url.startswith("https://github.com"):
            # 完全なURLはそのまま返す
            return repo_url

        # 正規表現で短縮形式を検証
        short_url_pattern = r"^(?!.*\.\.)[a-zA-Z0-9][a-zA-Z0-9\-\.]{0,38}/[a-zA-Z0-9][a-zA-Z0-9\-\.]{0,100}(\.git)?$"
        if re.match(short_url_pattern, repo_url):
            return f"https://github.com/{repo_url}"
        else:
            raise ValueError(
                "Invalid short-form repository URL. Must match 'author/repo-name' format."
            )

    @staticmethod
    def is_short_hand_url(url: str) -> bool:
        split_url = url.split("/")
        return (
            all(len(part) > 0 and part.isascii() for part in split_url)
            and len(split_url) == 2
        )

----
repo_tool/api/__init__.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from repo_tool.api.router import router

app = FastAPI(title="Repo Tool API", version="1.0.0")

origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(router)

----
repo_tool/api/router.py
import os
import tempfile
from typing import List, Optional

from dotenv import load_dotenv
from fastapi import HTTPException
from fastapi.responses import FileResponse
from fastapi.routing import APIRouter
from pydantic import BaseModel, Field

from repo_tool.core.digest import generate_digest_content
from repo_tool.core.filter import filter_files_in_repo, get_filter_settings
from repo_tool.core.github import GitHub, Repository
from repo_tool.core.summary import Summary, generate_summary

router = APIRouter()

load_dotenv(override=True)

github = GitHub()


class Response(BaseModel):
    status: str = Field(..., description="The status of the operation")


@router.get(
    "/repositories",
    summary="Get all repositories",
    description="Get all repositories",
)
def get_repositories() -> List[Repository]:
    return github.list()


@router.get(
    "/repositories/{author}/{repository_name}",
    summary="Get a repository",
    description="Get a repository",
)
def get_repository(author: str, repository_name: str) -> Repository:
    return github.get(author, repository_name)


class CloneRepositoryParams(BaseModel):
    url: str = Field(..., description="The URL of the repository to clone")
    branch: Optional[str] = Field(None, description="The branch to clone")


@router.post(
    "/repositories",
    response_model=Response,
    summary="Clone a repository",
    description="Clone a repository. If the URL is not provided, all repositories will be cloned.",
)
def clone_repository(request: CloneRepositoryParams) -> Response:
    github.clone(request.url, request.branch)
    return Response(status="success")


class DeleteRepositoryParams(BaseModel):
    url: Optional[str] = Field(None, description="The URL of the repository to delete")


@router.delete(
    "/repositories",
    response_model=Response,
    summary="Delete a repository",
    description="Delete a repository. If the URL is not provided, all repositories will be deleted.",
)
def delete_repository(request: DeleteRepositoryParams) -> Response:
    if request.url:
        github.remove(request.url)
    else:
        github.clean()
    return Response(status="success")


class UpdateRepositoryParams(BaseModel):
    url: Optional[str] = Field(None, description="The URL of the repository to update")
    branch: Optional[str] = Field(
        None, description="The branch to update (default: main)"
    )


@router.put(
    "/repositories",
    response_model=Response,
    summary="Update a repository",
    description="Update a repository. If the URL is not provided, all repositories will be updated.",
)
def update_repository(request: UpdateRepositoryParams) -> Response:
    if request.url:
        if not github.repo_exists(request.url):
            raise HTTPException(
                status_code=404, detail="Repository not found"
            )  # noqa: F821
        github.update(request.url)
    else:
        github.update()
    return Response(status="success")


@router.get(
    "/{author}/{repository_name}/summary",
    response_model=Summary,
    summary="Get a summary of a repository digest",
    description="Get a summary of a repository digest",
)
def get_summary_of_repository(author: str, repository_name: str) -> Summary:
    url = f"{author}/{repository_name}"
    if not github.repo_exists(url):
        raise HTTPException(status_code=404, detail="Repository not found")
    repo_path = GitHub.get_repo_path(url)
    filtered_files = filter_files_in_repo(repo_path, None)
    summary = generate_summary(repo_path, filtered_files)
    return summary


class GenerateDigestParams(BaseModel):
    url: str = Field(..., description="The URL of the repository to create a digest")
    branch: Optional[str] = Field(None, description="The branch to generate digest for")


@router.post(
    "/digest",
    response_class=FileResponse,
    summary="Create a digest of a repository",
    description="Create a digest of a repository. This will create a digest of the repository and return it as a file.",
)
def get_digest_of_repository(request: GenerateDigestParams) -> FileResponse:
    repo_path = GitHub.get_repo_path(request.url)
    if not github.repo_exists(request.url):
        github.clone(request.url, request.branch)
    elif request.branch:
        github.checkout(repo_path, request.branch)

    filtered_files = filter_files_in_repo(repo_path)
    digest = generate_digest_content(repo_path, filtered_files)

    # Create temporary file
    fd, temp_path = tempfile.mkstemp(suffix=".txt")
    try:
        with os.fdopen(fd, "w") as tmp:
            tmp.write(digest)

        # Get repository name for the filename
        repo_name = request.url.rstrip("/").split("/")[-1]
        filename = f"{repo_name}_digest.txt"

        return FileResponse(
            path=temp_path,
            filename=filename,
            media_type="text/plain",
            background=None,  # This ensures the temp file is removed after the response
        )
    except Exception as e:
        os.unlink(temp_path)  # Clean up the temp file in case of error
        raise HTTPException(status_code=500, detail=str(e))


class Settings(BaseModel):
    include_files: List[str] = Field(
        ..., description="The files to include in the digest"
    )
    exclude_files: List[str] = Field(
        ..., description="The files to exclude from the digest"
    )


@router.get("/settings")
def get_settings() -> Settings:
    settings = get_filter_settings()
    return Settings(
        include_files=settings.include_list,
        exclude_files=settings.ignore_list,
    )


@router.put("/settings")
def update_settings(request: Settings) -> Settings:
    with open(".gptignore", "w") as f:
        f.write("\n".join(request.exclude_files))
    with open(".gptinclude", "w") as f:
        f.write("\n".join(request.include_files))
    return Settings(
        include_files=request.include_files,
        exclude_files=request.exclude_files,
    )

--END--